<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gubby Clicker â€” Firestore Multiplayer + Chat</title>
<style>
  :root{
    --bg:#ffffff; --bg-2:#f5fbff;
    --accent:#6bc8ff; --accent2:#89ddff;
    --room-accent:#ffd28a; --room-accent2:#ffd4a3;
    --muted:#6b7280; --card:#fff;
    --max-width:1200px;
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Arial}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),var(--bg-2));transition:background .25s ease}
  body.room-mode{background:linear-gradient(180deg,#fff7ec,#fffaf5)}
  .container{max-width:var(--max-width);margin:18px auto;padding:12px;display:flex;flex-direction:column;gap:12px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px;border-radius:12px;background:linear-gradient(180deg,#fff,#fcfeff);box-shadow:0 8px 24px rgba(10,20,40,0.06)}
  .brand{display:flex;align-items:center;gap:12px}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent2));color:white;font-weight:800;display:flex;align-items:center;justify-content:center;font-size:22px}
  .title {font-size:18px;margin:0}
  .subtitle {font-size:12px;color:var(--muted)}
  .top-actions{display:flex;gap:8px;align-items:center}
  .btn{padding:10px 14px;border-radius:12px;border:0;background:var(--accent);color:white;font-weight:700;cursor:pointer;box-shadow:0 8px 18px rgba(75,110,255,0.08);transition:transform .12s,box-shadow .12s}
  .btn.secondary{background:white;color:var(--accent);border:1px solid rgba(75,110,255,0.12)}
  .btn.ghost{background:transparent;border:1px solid rgba(12,40,80,0.06);color:var(--muted)}
  .btn.small{padding:6px 8px;border-radius:8px;font-weight:600}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
  @media (max-width:1000px){ .grid{grid-template-columns:1fr 320px} }
  @media (max-width:800px){ .grid{grid-template-columns:1fr} header{flex-direction:column;align-items:stretch} .top-actions{justify-content:flex-end} }

  .card{border-radius:12px;background:var(--card);padding:14px;box-shadow:0 12px 40px rgba(10,20,40,0.04)}
  .play-area{display:flex;flex-direction:column;gap:12px;align-items:center}
  .house{width:100%;max-width:760px;height:420px;border-radius:10px;background:linear-gradient(180deg,#fff,#f3fbff);position:relative;overflow:hidden;border:1px solid rgba(12,40,80,0.05)}
  .gubby{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:130px;height:130px;transition:all .35s;cursor:pointer;user-select:none}
  .stats{display:flex;gap:12px;width:100%;justify-content:center;flex-wrap:wrap}
  .stat{min-width:160px;flex:1;max-width:240px;background:#fff;border-radius:10px;padding:10px 12px;border:1px solid rgba(12,40,80,0.04);text-align:center}
  .stat .label{font-size:12px;color:var(--muted)}
  .stat .value{font-weight:800;font-size:18px;margin-top:6px}
  .bar{height:12px;background:#eef6ff;border-radius:999px;margin-top:8px;overflow:hidden}
  .fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));transition:width .2s ease}
  body.room-mode .fill{background:linear-gradient(90deg,var(--room-accent),var(--room-accent2))}

  .controls{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-top:6px}

  .panel{padding:12px;border-radius:12px;background:var(--card);border:1px solid rgba(12,40,80,0.04)}
  .panel h4{margin:0 0 8px 0}
  .variants-list{display:flex;flex-direction:column;gap:8px}
  .variant-item{padding:8px;border-radius:10px;border:1px solid rgba(12,40,80,0.04);display:flex;justify-content:space-between;align-items:center;cursor:pointer}
  .member-list{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .member{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;border:1px solid rgba(12,40,80,0.04)}
  .room-code{font-weight:900;font-size:18px}

  .modal-backdrop{position:fixed;inset:0;background:rgba(8,10,20,0.5);display:none;align-items:center;justify-content:center;z-index:999}
  .modal{width:92%;max-width:980px;background:white;border-radius:12px;padding:18px;box-shadow:0 30px 90px rgba(10,20,40,0.3);transform:translateY(10px);opacity:0;transition:all .18s}
  .modal.show{transform:none;opacity:1}

  .shop-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  @media (max-width:1100px){ .shop-grid{grid-template-columns:repeat(2,1fr)} }
  @media (max-width:600px){ .shop-grid{grid-template-columns:1fr} }
  .shop-card{border-radius:12px;padding:12px;background:linear-gradient(180deg,#ffffff,#f8fcff);border:1px solid rgba(12,40,80,0.04);display:flex;flex-direction:column;gap:8px;min-height:110px}
  .shop-card .title{font-weight:800}
  .shop-card .price{font-weight:700;color:var(--muted)}
  .shop-tier{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}

  .chat-window{height:420px;display:flex;flex-direction:column;border:1px solid rgba(12,40,80,0.06);border-radius:8px;overflow:hidden}
  .chat-messages{flex:1;overflow:auto;padding:8px;background:#fbfdff}
  .chat-input{display:flex;gap:8px;padding:8px;border-top:1px solid rgba(12,40,80,0.04);background:white}

  footer{margin-top:12px;text-align:center;color:var(--muted);font-size:12px}
</style>
</head>
<body>
  <div class="container" id="root">
    <header>
      <div class="brand">
        <div class="logo">G</div>
        <div>
          <h1 class="title">Gubby Clicker</h1>
          <div class="subtitle" id="modeText">Solo play</div>
        </div>
      </div>

      <div class="top-actions" id="topActions">
        <div id="accountArea" style="display:flex;align-items:center;gap:10px">
          <div id="userInfo" class="subtitle">Not signed in</div>
          <button id="signInBtn" class="btn secondary">Sign in</button>
        </div>
        <button id="shopBtn" class="btn secondary">Shop</button>
      </div>
    </header>

    <div class="grid">
      <div class="card play-area">
        <div class="house" id="house">
          <img id="gubbySprite" class="gubby gubby-float" src="sprites/variants/default.png" draggable="false" alt="Gubby"/>
        </div>

        <div class="stats" id="hud">
          <div class="stat">
            <div class="label">HUNGER</div>
            <div class="value" id="hungerVal">0</div>
            <div class="bar"><div id="hungerFill" class="fill" style="width:0%"></div></div>
          </div>
          <div class="stat">
            <div class="label">THIRST</div>
            <div class="value" id="thirstVal">0</div>
            <div class="bar"><div id="thirstFill" class="fill" style="width:0%"></div></div>
          </div>
          <div class="stat">
            <div class="label">ENERGY</div>
            <div class="value" id="energyVal">0</div>
            <div class="bar"><div id="energyFill" class="fill" style="width:0%"></div></div>
          </div>
        </div>

        <div class="controls" role="toolbar" aria-label="controls">
          <button id="feedBtn" class="btn">Feed</button>
          <button id="waterBtn" class="btn secondary">Give Water</button>
          <button id="colaBtn" class="btn secondary">Bloxy Cola</button>
          <button id="playBtn" class="btn secondary">Play</button>
          <button id="hostBtn" class="btn">Host Game</button>
          <button id="joinBtn" class="btn secondary">Join Game</button>
          <button id="resetBtn" class="btn ghost" title="Request a room reset">Reset Room</button>
          <button id="chatBtn" class="btn small ghost hidden">ðŸ’¬ Chat</button>
        </div>

        <div class="subtitle">Click Gubby to earn clicks. Multiplayer actions sync with players in your room.</div>
      </div>

      <div style="display:flex;flex-direction:column;gap:12px">
        <div class="panel">
          <h4>Connection</h4>
          <div class="subtitle">Rooms: host & share a 4-letter code (login required).</div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
            <div>
              <div class="subtitle">Status</div>
              <div id="connectionStatus" style="font-weight:800">Not connected</div>
            </div>
            <div style="text-align:right">
              <div class="room-code" id="roomCodeDisplay"></div>
              <div style="display:flex;gap:8px;margin-top:6px;justify-content:flex-end">
                <button id="copyRoomBtn" class="btn small ghost hidden">Copy</button>
                <button id="leaveRoomBtn" class="btn small ghost hidden">Leave</button>
              </div>
            </div>
          </div>

          <div style="margin-top:12px">
            <div class="subtitle">Members</div>
            <div id="members" class="member-list"></div>
          </div>

          <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
            <button id="copyInviteBtn" class="btn small secondary hidden">Copy Room Link</button>
            <div id="resetStatus" class="subtitle" style="margin-left:auto"></div>
          </div>
        </div>

        <div class="panel">
          <h4>Account</h4>
          <div id="accountInfo" class="subtitle">â€”</div>
        </div>

        <div class="panel">
          <h4>Variants</h4>
          <div id="variantsList" class="variants-list"></div>
        </div>

        <div class="panel" id="adminPanel" style="display:none">
          <h4>Admin</h4>
          <div style="display:flex;flex-direction:column;gap:8px">
            <input id="variantId" placeholder="Variant ID"/>
            <input id="variantDisplay" placeholder="Display Name"/>
            <input id="variantFile" placeholder="sprite.png"/>
            <img id="variantPreview" style="max-width:140px;display:none"/>
            <input id="variantPrice" type="number" placeholder="Price" value="500"/>
            <input id="variantAttrs" type="hidden"/>
            <div style="display:flex;gap:8px">
              <button id="openAttr" class="btn secondary">Attributes</button>
              <button id="createVariant" class="btn">Create</button>
            </div>
          </div>
        </div>

      </div>
    </div>

    <footer class="subtitle">Gubby Clicker â€” Firestore rooms Â· 50+ synchronized shop items</footer>
  </div>

  <!-- Join modal -->
  <div class="modal-backdrop" id="joinModal"><div class="modal" id="joinBox">
    <h3>Join Room</h3>
    <input id="joinCodeInput" placeholder="4-letter code" maxlength="6"/>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button id="joinConfirm" class="btn">Join</button>
      <button id="closeJoin" class="btn secondary">Cancel</button>
    </div>
  </div></div>

  <!-- Shop modal -->
  <div class="modal-backdrop" id="shopModal"><div class="modal" id="shopBox">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h3>Massive Shop</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="subtitle">Clicks: <span id="clickCount">0</span></div>
        <button id="shopClose" class="btn secondary">Close</button>
      </div>
    </div>
    <div style="margin-top:12px">
      <div class="shop-tier" id="tierButtons"></div>
      <div id="shopGrid" class="shop-grid" style="margin-top:12px"></div>
    </div>
  </div></div>

  <!-- Chat modal -->
  <div class="modal-backdrop" id="chatModal"><div class="modal" id="chatBox" style="max-width:720px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h3>Room Chat</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <div id="chatRoomCode" class="subtitle"></div>
        <button id="chatClose" class="btn secondary">Close</button>
      </div>
    </div>
    <div style="margin-top:12px" class="chat-window">
      <div id="chatMessages" class="chat-messages"></div>
      <div class="chat-input">
        <input id="chatInput" placeholder="Say something..." style="flex:1;padding:10px;border-radius:8px;border:1px solid rgba(12,40,80,0.06)"/>
        <button id="chatSend" class="btn">Send</button>
        <button id="chatClear" class="btn ghost small">Clear</button>
      </div>
    </div>
  </div></div>

  <!-- Attr modal -->
  <div class="modal-backdrop" id="attrModal"><div class="modal" id="attrBox">
    <h3>Attributes</h3>
    <div style="display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center">
      <label><input type="checkbox" data-attr="clickMultiplier"> Click Multiplier</label><input class="attr-val" type="number" step="0.1" value="1.5"/>
      <label><input type="checkbox" data-attr="speed"> Speed</label><input class="attr-val" type="number" step="0.1" value="1.0"/>
      <label><input type="checkbox" data-attr="hungerDecay"> Hunger Decay</label><input class="attr-val" type="number" step="0.1" value="1.0"/>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button id="attrApply" class="btn">Apply</button>
      <button id="attrClose" class="btn secondary">Cancel</button>
    </div>
  </div></div>

  <!-- Reset modal -->
  <div class="modal-backdrop" id="resetModal"><div class="modal" id="resetBox">
    <h3>Request Room Reset</h3>
    <p class="subtitle">All players must agree. When everyone clicks "Agree", the room will reset and chat will be cleared.</p>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button id="resetAgree" class="btn">Agree</button>
      <button id="resetCancel" class="btn secondary">Cancel</button>
    </div>
  </div></div>

  <!-- Game Over modal -->
  <div class="modal-backdrop" id="gameOverBackdrop"><div class="modal" id="gameOverBox">
    <h3>Game Over</h3>
    <p class="subtitle">Gubby reached 0 in Hunger, Thirst or Energy for this room.</p>
    <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
      <button id="restartBtn" class="btn">Restart Locally</button>
      <button id="closeGameOver" class="btn secondary">Close</button>
    </div>
  </div></div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<script>
/* ================= CONFIG ================= */
const firebaseConfig = {
  apiKey: "AIzaSyAai5V9VTtPnAdMoAhhVe94fobPOY25yf8",
  authDomain: "gubby-clicker.firebaseapp.com",
  projectId: "gubby-clicker",
  storageBucket: "gubby-clicker.firebasestorage.app",
  messagingSenderId: "255072290621",
  appId: "1:255072290621:web:9f80676beac50c0059a754",
  measurementId: "G-R3HFMPH5C4"
};
const SPRITE_BASE_PATH = "sprites/variants/";
const SOUND_BASE_PATH  = "sounds/";

/* ================= STATE ================= */
const defaultState = {
  name:'Gubby',
  variant:'default.png',
  pos:{x:340,y:220},
  hunger:80, thirst:80, energy:100, alive:true,
  clicks:0, totalClicks:0,
  upgrades:{clickPower:1, autoClicks:0, multipliers:[]},
  backpack:{ food:5, water:5, cola:2 },
  lastUpdated: Date.now()
};
let state = loadState(); // this is the current *working* state (singleplayer or merged)
let user = null;
let auth = null;
let db = null;

/* UI refs */
const gubbySprite = document.getElementById('gubbySprite');
const hungerVal = document.getElementById('hungerVal'), thirstVal = document.getElementById('thirstVal'), energyVal = document.getElementById('energyVal');
const hungerFill = document.getElementById('hungerFill'), thirstFill = document.getElementById('thirstFill'), energyFill = document.getElementById('energyFill');

/* connection UI */
const connectionStatus = document.getElementById('connectionStatus'), roomCodeDisplay = document.getElementById('roomCodeDisplay');
const membersEl = document.getElementById('members'), copyRoomBtn = document.getElementById('copyRoomBtn'), leaveRoomBtn = document.getElementById('leaveRoomBtn');
const modeText = document.getElementById('modeText'), signInBtn = document.getElementById('signInBtn'), userInfo = document.getElementById('userInfo');
const chatBtn = document.getElementById('chatBtn');

/* chat refs */
const chatModal = document.getElementById('chatModal'), chatBox = document.getElementById('chatBox'), chatMessages = document.getElementById('chatMessages');
const chatInput = document.getElementById('chatInput'), chatSend = document.getElementById('chatSend'), chatClose = document.getElementById('chatClose');
const chatClear = document.getElementById('chatClear'), chatRoomCode = document.getElementById('chatRoomCode');

/* shop refs */
const shopModal = document.getElementById('shopModal'), shopBox = document.getElementById('shopBox'), shopGrid = document.getElementById('shopGrid'), tierButtons = document.getElementById('tierButtons');

/* other modals */
const joinModal = document.getElementById('joinModal'), joinBox = document.getElementById('joinBox');

let currentRoom = null;
let roomUnsub = null;
let membersUnsub = null;
let messagesUnsub = null;
let isHost = false;
let myPeerId = randomId();
let localSeq = 0;
let writeTimer = null;
const WRITE_DEBOUNCE_MS = 600;

/* shop data (50+ items) */
let shopData = [
  {id:'burger', title:'Burger', price:25, tier:'Basic', desc:'Food +1 (adds to backpack food)'},
  {id:'waterbottle', title:'Water Bottle', price:20, tier:'Basic', desc:'Water +1'},
  {id:'ball', title:'Bouncy Ball', price:50, tier:'Basic', desc:'Play toy'},
  {id:'smallbowl', title:'Small Bowl', price:80, tier:'Basic', desc:'Slightly reduces hunger decay'},
  {id:'waterfilter', title:'Water Filter', price:95, tier:'Basic', desc:'Reduces thirst decay'},
  {id:'toy1', title:'Rubber Duck', price:60, tier:'Basic', desc:'Play item'},
  {id:'clicker1', title:'Click Power +1', price:200, tier:'Upgrades', desc:'Increase click power'},
  {id:'autoclick1', title:'Auto-Clicker Mk I', price:600, tier:'Upgrades', desc:'+1 auto click tick'},
  {id:'bowl2', title:'Silver Bowl', price:400, tier:'Upgrades', desc:'Better food efficiency'},
  {id:'bed', title:'Cozy Bed', price:350, tier:'Upgrades', desc:'Energy recovers faster'},
  {id:'microphone', title:'DJ Microphone', price:480, tier:'Upgrades', desc:'Gubby likes musicâ€”small multiplier chance'},
  {id:'house_small', title:'Mini Gubby House', price:900, tier:'Quality', desc:'Nice home'},
  {id:'garden', title:'Garden', price:750, tier:'Quality', desc:'Auto grow snacks'},
  {id:'fountain', title:'Fountain', price:650, tier:'Quality', desc:'Relaxing water feature'},
  {id:'trainer', title:'Personal Trainer', price:1200, tier:'Quality', desc:'+2 energy during day'},
  {id:'gold_spoon', title:'Golden Feeding Spoon', price:2500, tier:'Luxury', desc:'Stylish and effective'},
  {id:'meteor_bed', title:'Meteor Rock Bed', price:3200, tier:'Luxury', desc:'Very comfy'},
  {id:'mansion', title:'Gubby Mansion', price:8000, tier:'Luxury', desc:'Luxury housing'},
  {id:'quantum_fig', title:'Quantum Fish Figurine', price:4200, tier:'Luxury', desc:'Strange properties'},
  {id:'particle_accel', title:'Particle Gubby Accelerator', price:15000, tier:'Endgame', desc:'Speeds up everything'},
  {id:'wormhole_portal', title:'Wormhole Snack Portal', price:22000, tier:'Endgame', desc:'Spawns rare snacks'},
  {id:'blackhole_tank', title:'Black Hole Fish Tank', price:20000, tier:'Endgame', desc:'Attracts cosmic pets'},
  {id:'quantum_accel', title:'Quantum Accelerator', price:30000, tier:'Endgame', desc:'Breaks time for clicks'},
  {id:'immortal_treat', title:'Immortal Treat', price:99999, tier:'Endgame', desc:'Gubby never gets hungry'},
  {id:'snackbox', title:'Snack Box', price:180, tier:'Basic', desc:'Mixed snacks'},
  {id:'soda_pack', title:'Cola Pack', price:350, tier:'Basic', desc:'+2 Cola'},
  {id:'toy2', title:'Squeaky Toy', price:120, tier:'Basic', desc:'Play toy'},
  {id:'auto_feeder2', title:'Auto-Feeder Mk II', price:2400, tier:'Upgrades', desc:'+5 auto clicks'},
  {id:'lux_cushion', title:'Luxury Cushion', price:900, tier:'Quality', desc:'Comfort'},
  {id:'gold_chalice', title:'Gold Chalice', price:5000, tier:'Luxury', desc:'Fancy drinking'},
  {id:'neon_sign', title:'Neon Gubby Sign', price:700, tier:'Quality', desc:'Stylish'},
  {id:'orb', title:'Mystic Orb', price:4200, tier:'Endgame', desc:'Weird energies'},
  {id:'pillow', title:'Pillow', price:75, tier:'Basic', desc:'Small comfort'},
  {id:'blanket', title:'Blanket', price:120, tier:'Basic', desc:'Cozy'},
  {id:'treats', title:'Treats (10)', price:300, tier:'Upgrades', desc:'Bulk snacks'},
  {id:'fancy_plate', title:'Fancy Plate', price:1100, tier:'Quality', desc:'Fine dining'},
  {id:'mystic_hat', title:'Mystic Hat', price:1300, tier:'Quality', desc:'Looks mysterious'},
  {id:'rocket_bed', title:'Rocket Bed', price:7600, tier:'Luxury', desc:'Bed with propulsion'},
  {id:'galaxy_pendant', title:'Galaxy Pendant', price:42000, tier:'Endgame', desc:'Very endgame'},
  {id:'time_clock', title:'Time Clock', price:12000, tier:'Endgame', desc:'Time-warping clock'},
  {id:'mini_farm', title:'Mini Farm', price:2200, tier:'Quality', desc:'Generates food slowly'},
  {id:'scented_candle', title:'Scented Candle', price:90, tier:'Basic', desc:'Pleasant aroma'},
  {id:'plushie', title:'Plushie', price:200, tier:'Basic', desc:'Cute friend'},
  {id:'laser_toy', title:'Laser Toy', price:480, tier:'Upgrades', desc:'Fun and energizing'},
  {id:'zen_garden', title:'Zen Garden', price:1400, tier:'Quality', desc:'Relaxation'},
  {id:'mystic_clock', title:'Mystic Clock', price:2400, tier:'Quality', desc:'Tick tocks nicely'},
  {id:'quantum_seed', title:'Quantum Seed', price:5200, tier:'Endgame', desc:'Grows unpredictable snacks'}
];
const tiers = Array.from(new Set(shopData.map(s=>s.tier)));
let currentTier = tiers[0];

/* audio */
let audioCtx=null, merpBuf=null;
async function loadMerp(){ try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); const r = await fetch(SOUND_BASE_PATH+'merp.mp3'); if(!r.ok){ merpBuf=null; return; } const ab = await r.arrayBuffer(); merpBuf = await audioCtx.decodeAudioData(ab); }catch(e){ merpBuf=null; } }
loadMerp();
function playMerp(){ if(merpBuf && audioCtx){ const s=audioCtx.createBufferSource(); s.buffer=merpBuf; s.playbackRate.value = 1 + (Math.random()*0.3 - .15); s.connect(audioCtx.destination); try{s.start(0)}catch(e){} }else try{ new Audio(SOUND_BASE_PATH+'merp.mp3').play().catch(()=>{}); }catch(e){} }

/* ============== UTIL ============== */
function el(id){ return document.getElementById(id); }
function randomId(){ return Math.random().toString(36).slice(2,9); }
function saveState(){ state.lastUpdated = Date.now(); localStorage.setItem('gubby_clicker_v1', JSON.stringify(state)); }
function loadState(){ try{ const r=localStorage.getItem('gubby_clicker_v1'); if(r) return JSON.parse(r); }catch(e){} return JSON.parse(JSON.stringify(defaultState)); }
function clamp(v, lo=0, hi=100){ return Math.max(lo, Math.min(hi, v)); }

/* apply UI */
function applyUI(){
  hungerVal.textContent = Math.round(state.hunger);
  thirstVal.textContent = Math.round(state.thirst);
  energyVal.textContent = Math.round(state.energy);
  hungerFill.style.width = clamp(state.hunger) + '%';
  thirstFill.style.width = clamp(state.thirst) + '%';
  energyFill.style.width = clamp(state.energy) + '%';
  el('accountInfo').textContent = user ? (user.displayName || user.email || 'You') : 'Not signed in';
  userInfo.textContent = user ? (user.displayName || user.email || 'You') : 'Not signed in';
  const clickCountEl = el('clickCount'); if(clickCountEl) clickCountEl.textContent = state.totalClicks || 0;
  gubbySprite.src = SPRITE_BASE_PATH + state.variant;
  if(state.pos && typeof state.pos.x === 'number') gubbySprite.style.left = state.pos.x + 'px';
  if(state.pos && typeof state.pos.y === 'number') gubbySprite.style.top = state.pos.y + 'px';
}
applyUI();

/* ================= FIREBASE init ================= */
function initFirebase(){
  if(window.firebase && !db){
    firebase.initializeApp(firebaseConfig);
    auth = firebase.auth();
    db = firebase.firestore();
    auth.onAuthStateChanged(async u => {
      user = u;
      if(user){
        signInBtn.style.display = 'none';
        userInfo.textContent = user.displayName || user.email || 'You';
        try{
          const userRef = db.collection('users').doc(user.uid);
          const userDoc = await userRef.get();
          if(!userDoc.exists) await userRef.set({ displayName:user.displayName||user.email||'guest', email:user.email||null, privileges:'normal', createdAt:Date.now() });
          const profile = (await userRef.get()).data();
          if(profile?.privileges === 'admin') el('adminPanel').style.display = 'block';
          else el('adminPanel').style.display = 'none';
          // load singleplayer from firestore if present (merge)
          await loadSingleplayerFromServer();
        }catch(e){ console.warn('user doc check failed', e); }
      } else {
        signInBtn.style.display = 'inline-block';
        userInfo.textContent = 'Not signed in';
        el('adminPanel').style.display = 'none';
        // when signed out, keep localStorage singleplayer if exists
        state = loadState();
        applyUI();
      }
    });

    // variants live
    db.collection('variants').onSnapshot(snap => {
      const arr = snap.docs.map(d => ({ id:d.id, ...d.data() }));
      renderVariants(arr);
    });

    window.__roomCache = null;
  }
}
initFirebase();

/* sign-in */
el('signInBtn').addEventListener('click', async ()=>{
  try{
    if(!db) initFirebase();
    const provider = new firebase.auth.GoogleAuthProvider();
    await firebase.auth().signInWithPopup(provider);
  }catch(e){ alert('Sign-in failed: ' + (e.message||e)); }
});

async function requireSignIn(){ if(!auth) initFirebase(); if(!auth.currentUser){ alert('Please sign in to use multiplayer.'); return false; } return true; }

/* ================= SINGLEPLAYER STORAGE ================= */
/* singleplayer is stored at users/{uid}/singleplayerState (if signed in)
   otherwise localStorage is used.
*/
async function loadSingleplayerFromServer(){
  try{
    if(!auth || !auth.currentUser) return;
    const ref = db.collection('users').doc(auth.currentUser.uid).collection('singleplayerState').doc('state');
    const snap = await ref.get();
    if(snap.exists){
      const docState = snap.data();
      // merge server singleplayer into local
      state = Object.assign({}, state, docState);
      saveState();
      applyUI();
    } else {
      // if none, create one from current local
      await ref.set(state);
    }
  }catch(e){ console.warn('load singleplayer failed', e); }
}

async function saveSingleplayerToServer(){
  try{
    if(!auth || !auth.currentUser) return;
    const ref = db.collection('users').doc(auth.currentUser.uid).collection('singleplayerState').doc('state');
    await ref.set(state, { merge: true });
  }catch(e){ console.warn('save singleplayer failed', e); }
}

/* helpers for owned items in singleplayer */
async function getSingleplayerOwned(){
  if(auth && auth.currentUser){
    try{
      const ref = db.collection('users').doc(auth.currentUser.uid).collection('singleplayerState').doc('state');
      const snap = await ref.get();
      if(snap.exists) return snap.data().shopOwned || [];
    }catch(e){ console.warn('getSingleplayerOwned failed', e); }
  }
  // fallback to localStorage
  try{
    const raw = localStorage.getItem('gubby_single_owned');
    if(raw) return JSON.parse(raw);
  }catch(e){}
  return [];
}
async function addSingleplayerOwned(id){
  if(auth && auth.currentUser){
    try{
      const ref = db.collection('users').doc(auth.currentUser.uid).collection('singleplayerState').doc('state');
      await db.runTransaction(async tx => {
        const snap = await tx.get(ref);
        const data = snap.exists ? snap.data() : {};
        const owned = data.shopOwned || [];
        if(!owned.includes(id)) owned.push(id);
        if(!snap.exists) tx.set(ref, Object.assign({}, state, { shopOwned: owned }));
        else tx.update(ref, { shopOwned: owned });
      });
      return;
    }catch(e){ console.warn('addSingleplayerOwned failed', e); }
  }
  // local fallback
  try{
    const raw = localStorage.getItem('gubby_single_owned');
    const arr = raw ? JSON.parse(raw) : [];
    if(!arr.includes(id)) arr.push(id);
    localStorage.setItem('gubby_single_owned', JSON.stringify(arr));
  }catch(e){}
}

/* ================= ROOM: host/join/leave/listen ================= */
function genCode(){
  const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
  let s=''; for(let i=0;i<4;i++) s+=letters[Math.floor(Math.random()*letters.length)];
  return s;
}

async function hostRoom(){
  if(!await requireSignIn()) return;
  if(currentRoom) return alert('Leave existing room first.');
  for(let attempt=0; attempt<6; attempt++){
    const code = genCode();
    try{
      const ref = db.collection('rooms').doc(code);
      const snap = await ref.get();
      if(!snap.exists){
        isHost = true; currentRoom = code;
        const payload = { state: state, shopOwned: [], resetVotes: [], hostUid: auth.currentUser.uid, from: myPeerId, seq: ++localSeq, createdAt: Date.now() };
        await ref.set(payload);
        await ref.collection('members').doc(auth.currentUser.uid).set({ uid: auth.currentUser.uid, displayName: auth.currentUser.displayName||auth.currentUser.email||'You', joinedAt: Date.now() });
        listenRoom(code);
        listenMembers(code);
        updateRoomUI(true, code);
        alert('Room created: ' + code);
        return;
      }
    }catch(e){ console.warn('host attempt failed', e); }
  }
  alert('Failed to create room, try again.');
}

async function joinRoom(code){
  if(!await requireSignIn()) return;
  if(currentRoom) return alert('Already in a room.');
  code = (code||'').trim().toUpperCase();
  if(!code) return alert('Enter room code');
  try{
    const ref = db.collection('rooms').doc(code);
    const snap = await ref.get();
    if(!snap.exists) return alert('Room not found: ' + code);
    currentRoom = code; isHost = false;
    await ref.collection('members').doc(auth.currentUser.uid).set({ uid: auth.currentUser.uid, displayName: auth.currentUser.displayName||auth.currentUser.email||'You', joinedAt: Date.now() });
    listenRoom(code);
    listenMembers(code);
    updateRoomUI(true, code);
    alert('Joined ' + code);
  }catch(e){ alert('Join failed: ' + (e.message||e)); }
}

async function leaveRoom(userRequested=true){
  if(!currentRoom) return;
  try{
    const code = currentRoom;
    const ref = db.collection('rooms').doc(code);
    if(auth && auth.currentUser){
      await ref.collection('members').doc(auth.currentUser.uid).delete().catch(()=>{});
    }
    if(isHost){
      const mSnap = await ref.collection('members').limit(1).get();
      if(mSnap.empty) await ref.delete().catch(()=>{});
    }
  }catch(e){ console.warn('leave error', e); }
  if(roomUnsub){ roomUnsub(); roomUnsub = null; }
  if(membersUnsub){ membersUnsub(); membersUnsub = null; }
  if(messagesUnsub){ messagesUnsub(); messagesUnsub = null; }
  currentRoom = null; isHost = false;
  document.body.classList.remove('room-mode');
  modeText.textContent = 'Solo play';
  roomCodeDisplay.textContent = '';
  copyRoomBtn.classList.add('hidden'); leaveRoomBtn.classList.add('hidden'); chatBtn.classList.add('hidden');
  connectionStatus.textContent = 'Not connected';
  membersEl.innerHTML = '';
  // reload singleplayer local or server back into state
  if(user) await loadSingleplayerFromServer(); else state = loadState();
  applyUI();
}

function listenRoom(code){
  if(roomUnsub) roomUnsub();
  const ref = db.collection('rooms').doc(code);
  roomUnsub = ref.onSnapshot(snap => {
    if(!snap.exists){ alert('Room closed'); leaveRoom(false); return; }
    const data = snap.data();
    if(!data) return;
    const from = data.from;
    if(from !== myPeerId){
      if(data.state) mergeRemoteState(data.state);
    }
    window.__roomCache = data;
    renderShopGrid(currentTier);
    updateResetStatus(data.resetVotes || []);
  }, err => console.warn('room listen err', err));
}

function listenMembers(code){
  if(membersUnsub) membersUnsub();
  const mRef = db.collection('rooms').doc(code).collection('members');
  membersUnsub = mRef.onSnapshot(snap => {
    const arr = [];
    snap.forEach(d => arr.push(d.data()));
    renderMembers(arr);
  }, err => console.warn('members listen err', err));
}

/* ============== MEMBERS UI ============== */
function renderMembers(list){
  membersEl.innerHTML = '';
  list.forEach(m => {
    const div = document.createElement('div'); div.className='member';
    div.innerHTML = `<div style="width:40px;height:40px;border-radius:8px;background:#f0f0f0;display:flex;align-items:center;justify-content:center;font-weight:800">${(m.displayName||m.uid||'U')[0].toUpperCase()}</div>
      <div style="display:flex;flex-direction:column"><div style="font-weight:800">${m.displayName||m.uid}</div><div class="subtitle">joined</div></div>`;
    membersEl.appendChild(div);
  });
}

/* update UI on join/leave */
function updateRoomUI(connected, code){
  if(connected){
    document.body.classList.add('room-mode');
    modeText.textContent = 'In room';
    connectionStatus.textContent = 'Connected';
    roomCodeDisplay.textContent = code||'';
    copyRoomBtn.classList.remove('hidden'); leaveRoomBtn.classList.remove('hidden'); chatBtn.classList.remove('hidden'); el('copyInviteBtn').classList.remove('hidden');
  } else {
    document.body.classList.remove('room-mode');
    modeText.textContent = 'Solo play';
    connectionStatus.textContent = 'Not connected';
    roomCodeDisplay.textContent = ''; copyRoomBtn.classList.add('hidden'); leaveRoomBtn.classList.add('hidden'); chatBtn.classList.add('hidden'); el('copyInviteBtn').classList.add('hidden');
  }
}

/* ============== SCHEDULED WRITES (room OR singleplayer) ============== */
function scheduleWrite(){
  saveState(); applyUI();
  if(!currentRoom){
    // singleplayer: save to server if signed in or to localStorage
    if(user) saveSingleplayerToServer().catch(e => console.warn('save singleplayer fail', e));
    return;
  }
  if(writeTimer) clearTimeout(writeTimer);
  writeTimer = setTimeout(()=> writeRoomNow(), WRITE_DEBOUNCE_MS);
}
function writeRoomNow(){
  if(!currentRoom) return;
  const ref = db.collection('rooms').doc(currentRoom);
  const payload = { state: state, from: myPeerId, seq: ++localSeq, lastUpdated: Date.now() };
  ref.set(payload, { merge: true }).catch(e=>console.warn('write failed', e));
}

/* merge remote state conservatively */
function mergeRemoteState(remote){
  if(!remote) return;
  if(remote.totalClicks > state.totalClicks){
    state.totalClicks = remote.totalClicks;
    state.upgrades = remote.upgrades || state.upgrades;
    state.variant = remote.variant || state.variant;
  }
  state.backpack.food = Math.max(state.backpack.food, remote.backpack?.food || 0);
  state.backpack.water = Math.max(state.backpack.water, remote.backpack?.water || 0);
  state.backpack.cola = Math.max(state.backpack.cola, remote.backpack?.cola || 0);
  state.hunger = Math.round((state.hunger + (remote.hunger||state.hunger))/2);
  state.thirst = Math.round((state.thirst + (remote.thirst||state.thirst))/2);
  state.energy = Math.round((state.energy + (remote.energy||state.energy))/2);
  saveState(); applyUI();
}

/* ============== SHOP UI & SYNC (handles singleplayer & multiplayer) ============== */
function openShop(){
  el('shopModal').style.display='flex'; setTimeout(()=> el('shopBox').classList.add('show'), 10);
  renderTierButtons(); renderShopGrid(currentTier);
}
function closeShop(){ el('shopBox').classList.remove('show'); setTimeout(()=> el('shopModal').style.display='none', 180); }
el('shopBtn').addEventListener('click', openShop);
el('shopClose').addEventListener('click', closeShop);

function renderTierButtons(){
  tierButtons.innerHTML = '';
  tiers.forEach(t=>{
    const b = document.createElement('button'); b.className='btn small secondary'; b.textContent = t;
    if(t === currentTier){ b.classList.add('btn'); b.classList.remove('secondary'); }
    b.addEventListener('click', ()=>{ currentTier = t; renderTierButtons(); renderShopGrid(t); });
    tierButtons.appendChild(b);
  });
}

async function renderShopGrid(tier){
  shopGrid.innerHTML = '';
  const list = shopData.filter(s => s.tier === tier);
  let owned = [];
  if(currentRoom && window.__roomCache){
    owned = window.__roomCache.shopOwned || [];
  } else {
    // solo mode: read singleplayer owned
    try{ owned = await getSingleplayerOwned(); }catch(e){ owned = []; }
  }
  list.forEach(it => {
    const card = document.createElement('div'); card.className='shop-card';
    const ownedFlag = owned.includes(it.id);
    card.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="title">${it.title}</div>
          <div class="subtitle">${it.desc}</div>
        </div>
        <div style="text-align:right">
          <div class="price">${it.price} âœ¨</div>
        </div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
        <div class="subtitle">${it.id}</div>
        <div><button class="btn small ${ownedFlag ? 'ghost secondary' : ''}" ${ownedFlag ? 'disabled' : ''}>${ownedFlag ? 'Owned' : 'Buy'}</button></div>
      </div>`;
    const btn = card.querySelector('button');
    btn.addEventListener('click', ()=> buyItem(it));
    shopGrid.appendChild(card);
  });
}

/* buyItem: handles singleplayer (user/local) and multiplayer (transaction) */
async function buyItem(item){
  // SINGLEPLAYER if not in a room
  if(!currentRoom){
    // deduct from player's personal clicks (state.totalClicks)
    if(state.totalClicks < item.price) return alert('Not enough clicks in your singleplayer save.');
    state.totalClicks -= item.price;
    // apply simple effects
    if(item.id === 'burger') state.backpack.food = (state.backpack.food||0) + 1;
    if(item.id === 'waterbottle') state.backpack.water = (state.backpack.water||0) + 1;
    if(item.id === 'clicker1') state.upgrades.clickPower = (state.upgrades.clickPower||1) + 1;
    if(item.id === 'autoclick1') state.upgrades.autoClicks = (state.upgrades.autoClicks||0) + 1;
    saveState(); applyUI();
    // record ownership
    try{
      await addSingleplayerOwned(item.id);
      alert('Purchased (singleplayer): ' + item.title);
      renderShopGrid(currentTier);
    }catch(e){ console.warn('singleplayer buy record failed', e); alert('Purchased locally, but failed to persist ownership.'); }
    return;
  }

  // MULTIPLAYER: use a Firestore transaction to update room state & shopOwned
  if(!user) return alert('Sign in to buy in multiplayer.');
  const roomRef = db.collection('rooms').doc(currentRoom);
  try{
    await db.runTransaction(async tx => {
      const snap = await tx.get(roomRef);
      if(!snap.exists) throw new Error('Room missing');
      const data = snap.data();
      const owned = data.shopOwned || [];
      if(owned.includes(item.id)) throw new Error('Already owned in this room');
      const roomState = data.state || {};
      const totalClicks = Number(roomState.totalClicks || 0);
      if(totalClicks < item.price) throw new Error('Not enough room clicks balance');
      const newOwned = owned.concat([item.id]);
      const newState = Object.assign({}, roomState);
      newState.totalClicks = totalClicks - item.price;
      // small sample effects
      if(item.id === 'burger') newState.backpack = Object.assign({}, newState.backpack, { food: (newState.backpack?.food||0)+1 });
      if(item.id === 'waterbottle') newState.backpack = Object.assign({}, newState.backpack, { water: (newState.backpack?.water||0)+1 });
      if(item.id === 'clicker1') newState.upgrades = Object.assign({}, newState.upgrades, { clickPower: (newState.upgrades?.clickPower||1)+1 });
      if(item.id === 'autoclick1') newState.upgrades = Object.assign({}, newState.upgrades, { autoClicks: (newState.upgrades?.autoClicks||0)+1 });
      if(item.id === 'particle_accel') newState.upgrades = Object.assign({}, newState.upgrades, { clickPower: (newState.upgrades?.clickPower||1)*1.5 });
      tx.update(roomRef, { shopOwned: newOwned, state: newState, from: myPeerId, seq: ++localSeq, lastUpdated: Date.now() });
      // update local copy for immediate feedback
      state = newState;
    });
    applyUI();
    renderShopGrid(currentTier);
    alert('Purchased ' + item.title);
  }catch(e){
    console.warn('purchase failed', e);
    alert('Purchase failed: ' + (e.message || e));
  }
}

/* ============== CHAT (messages subcollection) ============== */
function openChat(){
  if(!currentRoom) return alert('Join a room to chat.');
  chatModal.style.display = 'flex';
  setTimeout(()=> chatBox.classList.add('show'), 10);
  chatRoomCode.textContent = currentRoom ? `Room ${currentRoom}` : '';
  listenMessages(currentRoom);
}
function closeChat(){
  if(messagesUnsub){ messagesUnsub(); messagesUnsub = null; }
  chatBox.classList.remove('show'); setTimeout(()=> chatModal.style.display = 'none', 180);
}
chatClose.addEventListener('click', closeChat);
chatBtn.addEventListener('click', openChat);

function listenMessages(code){
  if(messagesUnsub) messagesUnsub();
  const msgsRef = db.collection('rooms').doc(code).collection('messages').orderBy('createdAt','asc').limit(500);
  messagesUnsub = msgsRef.onSnapshot(snap => {
    chatMessages.innerHTML = '';
    snap.forEach(doc => {
      const m = doc.data();
      const elMsg = document.createElement('div');
      elMsg.style.marginBottom = '8px';
      elMsg.innerHTML = `<div style="font-weight:700">${escapeHtml(m.name || m.uid)}</div><div class="subtitle">${escapeHtml(m.text)}</div><div style="font-size:11px;color:var(--muted)">${new Date(m.createdAt).toLocaleTimeString()}</div>`;
      chatMessages.appendChild(elMsg);
    });
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }, err => {
    console.warn('messages listen err', err);
    alert('Chat listen error: ' + (err.message || err));
  });
}

chatSend.addEventListener('click', sendChatMessage);
chatInput.addEventListener('keydown', (e)=> { if(e.key === 'Enter') sendChatMessage(); });

async function sendChatMessage(){
  if(!currentRoom) return alert('Join a room first.');
  if(!user) return alert('Sign in to chat.');
  const text = (chatInput.value || '').trim();
  if(!text) return;
  const msgsRef = db.collection('rooms').doc(currentRoom).collection('messages');
  try{
    await msgsRef.add({ uid: auth.currentUser.uid, name: auth.currentUser.displayName || auth.currentUser.email || 'You', text, createdAt: Date.now() });
    chatInput.value = '';
  }catch(e){
    console.warn('send chat failed', e);
    // show clearer permission diagnostics
    alert('Send chat failed: ' + (e.message || e) + '\nCheck Firestore rules to allow authenticated users to write to rooms/messages.');
  }
}

chatClear.addEventListener('click', async ()=>{
  if(!currentRoom) return alert('Join a room first');
  if(!confirm('Clear chat for everyone in this room?')) return;
  if(!auth || !auth.currentUser) return alert('Sign in required');
  try{
    const msgsRef = db.collection('rooms').doc(currentRoom).collection('messages');
    const snap = await msgsRef.get();
    const batch = db.batch();
    snap.forEach(d => batch.delete(d.ref));
    await batch.commit();
    alert('Chat cleared');
  }catch(e){ console.warn('clear chat failed', e); alert('Clear chat failed: ' + (e.message||e)); }
});

/* ============== RESET: unanimous votes and clearing chat ============== */
el('resetBtn').addEventListener('click', ()=> {
  if(!currentRoom) return alert('Join a room to request reset');
  el('resetModal').style.display = 'flex'; setTimeout(()=> el('resetBox').classList.add('show'), 10);
});
el('resetCancel').addEventListener('click', ()=> { el('resetBox').classList.remove('show'); setTimeout(()=> el('resetModal').style.display='none',180); });

el('resetAgree').addEventListener('click', async ()=>{
  if(!currentRoom) return;
  const roomRef = db.collection('rooms').doc(currentRoom);
  try{
    await db.runTransaction(async tx => {
      const snap = await tx.get(roomRef);
      if(!snap.exists) throw new Error('Room missing');
      const data = snap.data();
      const resetVotes = new Set(data.resetVotes || []);
      resetVotes.add(auth.currentUser.uid);
      const membersSnap = await roomRef.collection('members').get();
      const memberIds = [];
      membersSnap.forEach(m => memberIds.push(m.id));
      if(memberIds.length === 0){
        tx.update(roomRef, { state: defaultState, resetVotes: [], shopOwned: [], from: myPeerId, seq: ++localSeq, lastUpdated: Date.now() });
      } else if(memberIds.every(id => resetVotes.has(id))){
        tx.update(roomRef, { state: defaultState, resetVotes: [], shopOwned: [], from: myPeerId, seq: ++localSeq, lastUpdated: Date.now() });
      } else {
        tx.update(roomRef, { resetVotes: Array.from(resetVotes), from: myPeerId, seq: ++localSeq, lastUpdated: Date.now() });
      }
    });

    // after transaction, check if reset occurred and clear messages
    const doc = await roomRef.get();
    const dataAfter = doc.data();
    if(dataAfter && Array.isArray(dataAfter.resetVotes) && dataAfter.resetVotes.length === 0){
      // clear messages (batched)
      try{
        const msgsRef = roomRef.collection('messages');
        const snap = await msgsRef.get();
        if(!snap.empty){
          const batches = [];
          let batch = db.batch(), ops = 0;
          snap.forEach(d => { batch.delete(d.ref); ops++; if(ops === 500){ batches.push(batch); batch = db.batch(); ops = 0; } });
          batches.push(batch);
          for(const b of batches) await b.commit();
        }
      }catch(e){ console.warn('post-reset message deletion failed', e); }
    }

    el('resetBox').classList.remove('show'); setTimeout(()=> el('resetModal').style.display='none',180);
    alert('Your vote was recorded. Reset happens when all members agree. Chat will be cleared if reset occurs.');
  }catch(e){ console.warn('reset tx failed', e); alert('Reset failed: ' + (e.message||e)); }
});

/* update reset status UI */
async function updateResetStatus(votes){
  if(!currentRoom){ el('resetStatus').textContent = ''; return; }
  try{
    const membersSnap = await db.collection('rooms').doc(currentRoom).collection('members').get();
    const memberCount = membersSnap.size;
    el('resetStatus').textContent = `${(votes||[]).length} / ${memberCount} agreed`;
  }catch(e){ el('resetStatus').textContent = `${(votes||[]).length} votes`; }
}

/* ============== GAME: clicks, items, decay ============== */
function clickGubby(){
  if(!state.alive) return;
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
  const mult = (state.upgrades.multipliers || []).reduce((a,b)=>a*b,1) || 1;
  const power = (state.upgrades.clickPower || 1) * mult;
  state.clicks += power; state.totalClicks += power;
  state.hunger = Math.max(0, state.hunger - 0.1);
  state.thirst = Math.max(0, state.thirst - 0.2);
  playMerp();
  scheduleWrite();
}
gubbySprite.addEventListener('click', clickGubby);

function useBackpack(type){
  if(!state.alive) return;
  if(!state.backpack[type] || state.backpack[type] <= 0) return alert('No item');
  state.backpack[type] -= 1;
  if(type==='food') state.hunger = Math.min(100, state.hunger + 25);
  if(type==='water') state.thirst = Math.min(100, state.thirst + 25);
  if(type==='cola') state.energy = Math.min(100, state.energy + 50);
  scheduleWrite();
}
el('feedBtn').addEventListener('click', ()=> useBackpack('food'));
el('waterBtn').addEventListener('click', ()=> useBackpack('water'));
el('colaBtn').addEventListener('click', ()=> useBackpack('cola'));
el('playBtn').addEventListener('click', ()=> { state.energy = Math.min(100, state.energy + 8); scheduleWrite(); });

/* wander + decay loops */
function wander(){
  if(!state.alive) return;
  const margin = 80;
  const newX = Math.random()*(680 - margin*2) + margin;
  const newY = Math.random()*(360 - margin*2) + margin;
  const dx = (state.pos?.x||newX) - newX;
  const dy = (state.pos?.y||newY) - newY;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const loss = Math.max(1, Math.round(dist/60));
  state.pos.x = newX; state.pos.y = newY;
  state.energy = Math.max(0, state.energy - loss);
  gubbySprite.style.left = newX + 'px'; gubbySprite.style.top = newY + 'px';
  scheduleWrite();
}
setInterval(wander, 3000);

setInterval(()=>{
  if(!state.alive) return;
  state.hunger = Math.max(0, state.hunger - (state.upgrades?.hungerDecayMod || 1));
  state.thirst = Math.max(0, state.thirst - (state.upgrades?.thirstDecayMod || 1.2));
  const hour = (new Date()).getHours();
  if(hour>=22||hour<7) state.energy = Math.min(100, state.energy + (state.upgrades?.energyGain||2)); else state.energy = Math.max(0, state.energy - 0.5);
  if(state.hunger === 0 || state.thirst === 0) state.energy = Math.max(0, state.energy - 2);
  if(state.upgrades.autoClicks > 0) addClicks(state.upgrades.autoClicks);
  if(state.energy <= 0 || state.hunger <= 0 || state.thirst <= 0){
    state.alive = false;
    scheduleWrite();
    showGameOver();
  }
  scheduleWrite();
}, 10000);

function addClicks(n){ state.clicks += n; state.totalClicks += n; saveState(); applyUI(); }

/* game over UI */
function showGameOver(){ el('gameOverBackdrop').style.display='flex'; setTimeout(()=> el('gameOverBox').classList.add('show'), 10); }
function hideGameOver(){ el('gameOverBox').classList.remove('show'); setTimeout(()=> el('gameOverBackdrop').style.display='none', 200); }
el('restartBtn').addEventListener('click', ()=> {
  state = JSON.parse(JSON.stringify(defaultState));
  scheduleWrite();
  saveState(); applyUI(); hideGameOver();
});

/* ============== VARIANTS admin ============== */
function renderVariants(items){
  const wrap = el('variantsList'); wrap.innerHTML = '';
  items.forEach(v=>{
    const d = document.createElement('div'); d.className = 'variant-item';
    d.innerHTML = `<div><strong>${v.displayName||v.id}</strong><div class="subtitle">${v.fileName}</div></div><div><button class="btn small">Select</button></div>`;
    d.querySelector('button').addEventListener('click', ()=> { state.variant = v.fileName; scheduleWrite(); applyUI(); });
    wrap.appendChild(d);
  });
}
el('variantFile').addEventListener('input', (e)=> {
  const v = e.target.value.trim(); if(!v){ el('variantPreview').style.display='none'; return; }
  el('variantPreview').src = SPRITE_BASE_PATH + v; el('variantPreview').style.display='block';
});
el('createVariant').addEventListener('click', async ()=> {
  if(!db || !auth || !auth.currentUser) return alert('Sign-in required');
  const id = el('variantId').value.trim(), display = el('variantDisplay').value.trim(), file = el('variantFile').value.trim(), price = Number(el('variantPrice').value||0);
  let attrs = {};
  try{ attrs = JSON.parse(el('variantAttrs').value || '{}'); }catch(e){ return alert('Invalid attrs JSON'); }
  if(!id || !file) return alert('Provide id & file');
  try{
    await db.collection('variants').add({ id, displayName: display||id, fileName: file, price, attributes: attrs, createdBy: auth.currentUser.uid, createdAt: Date.now() });
    alert('Created');
  }catch(e){ alert('Create variant failed: ' + (e.message||e)); }
});

/* ============== UI wiring ============== */
el('hostBtn').addEventListener('click', async ()=> { if(!db) initFirebase(); if(!auth) initFirebase(); try{ if(!auth.currentUser) await auth.signInWithPopup(new firebase.auth.GoogleAuthProvider()); }catch(e){} hostRoom(); });
el('joinBtn').addEventListener('click', ()=>{ el('joinModal').style.display='flex'; setTimeout(()=> el('joinBox').classList.add('show'),10); });
el('closeJoin').addEventListener('click', ()=>{ el('joinBox').classList.remove('show'); setTimeout(()=> el('joinModal').style.display='none',180); });
el('joinConfirm').addEventListener('click', ()=>{ const code = el('joinCodeInput').value.trim(); if(!code) return alert('Enter code'); joinRoom(code); el('joinBox').classList.remove('show'); setTimeout(()=> el('joinModal').style.display='none',180); });

copyRoomBtn.addEventListener('click', ()=> {
  if(!currentRoom) return;
  navigator.clipboard?.writeText(currentRoom).then(()=> alert('Copied room code'), ()=> alert('Copy failed'));
});
el('copyInviteBtn').addEventListener('click', ()=> {
  if(!currentRoom) return;
  const link = location.href.split('#')[0] + '#room=' + currentRoom;
  navigator.clipboard?.writeText(link).then(()=> alert('Room link copied'), ()=> alert('Copy failed'));
});
leaveRoomBtn.addEventListener('click', ()=> { if(confirm('Leave room?')) leaveRoom(true); });

/* chat open binding */
el('chatBtn') && el('chatBtn').addEventListener('click', openChat);

/* cleanup on unload (best-effort presence) */
window.addEventListener('beforeunload', async ()=>{
  try{
    if(currentRoom && db && auth && auth.currentUser){
      await db.collection('rooms').doc(currentRoom).collection('members').doc(auth.currentUser.uid).delete().catch(()=>{});
      if(isHost){
        const members = await db.collection('rooms').doc(currentRoom).collection('members').limit(1).get();
        if(members.empty) await db.collection('rooms').doc(currentRoom).delete().catch(()=>{});
      }
    }
  }catch(e){}
});

/* small helpers */
function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]); }

/* init bindings on DOM ready */
document.addEventListener('DOMContentLoaded', ()=> {
  applyUI();
  el('shopBtn').addEventListener('click', openShop);
  el('shopClose').addEventListener('click', closeShop);
  el('chatClose').addEventListener('click', closeChat);
  el('chatSend').addEventListener('click', sendChatMessage);
  el('chatInput').addEventListener('keydown', (e)=> { if(e.key === 'Enter') sendChatMessage(); });
  el('chatClear').addEventListener('click', async ()=> {
    if(!currentRoom) return alert('Join a room first');
    if(!confirm('Clear chat for everyone?')) return;
    try{
      const msgsRef = db.collection('rooms').doc(currentRoom).collection('messages');
      const snap = await msgsRef.get();
      const batch = db.batch();
      snap.forEach(d => batch.delete(d.ref));
      await batch.commit();
      alert('Chat cleared');
    }catch(e){ console.warn('clear failed', e); alert('Clear failed: ' + (e.message||e)); }
  });
  el('resetBtn').addEventListener('click', ()=> { if(!currentRoom) return alert('Join a room first'); el('resetModal').style.display='flex'; setTimeout(()=> el('resetBox').classList.add('show'),10); });
});

/* expose debug */
window.GubbyClicker = { state, saveState, loadState, openShop, hostRoom, joinRoom, leaveRoom };

/* End of script */
</script>
</body>
</html>
