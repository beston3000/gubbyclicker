<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gubby Clicker â€” Firestore Multiplayer</title>
  <style>
    :root{
      --bg:#ffffff; --bg-2:#f4fbff;
      --accent:#61b7ff; --accent2:#8fd6ff;
      --room-accent:#ffd9a8; --room-accent2:#ffe7c9;
      --muted:#6b7280; --card:#fff;
      --maxw:1200px;
    }
    *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Arial}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),var(--bg-2));-webkit-user-select:none;-ms-user-select:none;user-select:none;}
    body.room-mode{background:linear-gradient(180deg,var(--room-accent),var(--room-accent2));}
    .wrap{max-width:var(--maxw);margin:20px auto;padding:14px;display:flex;flex-direction:column;gap:12px}
    header{display:flex;justify-content:space-between;align-items:center;padding:12px;background:var(--card);border-radius:10px;box-shadow:0 10px 40px rgba(10,20,40,0.06)}
    .brand{display:flex;align-items:center;gap:12px}
    .logo{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent2));display:flex;align-items:center;justify-content:center;color:white;font-weight:800}
    .title{font-size:18px;margin:0}
    .subtitle{font-size:13px;color:var(--muted)}
    .top-actions{display:flex;gap:8px;align-items:center}
    .btn{padding:10px 12px;border-radius:10px;border:0;background:var(--accent);color:white;font-weight:700;cursor:pointer;transition: all .2s;}
    .btn:hover{filter:brightness(1.1);}
    .btn.secondary{background:white;color:var(--accent);border:1px solid rgba(75,110,255,0.12)}
    .btn.ghost{background:transparent;border:1px solid rgba(12,40,80,0.06);color:var(--muted)}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:14px}
    @media (max-width:1000px){ .grid{grid-template-columns:1fr 320px} }
    @media (max-width:760px){ .grid{grid-template-columns:1fr} header{flex-direction:column;align-items:stretch} .top-actions{justify-content:flex-end} }
    .card{background:var(--card);padding:12px;border-radius:10px;border:1px solid rgba(12,40,80,0.04)}
    .house{height:420px;border-radius:10px;background:linear-gradient(180deg,#fff,#eef9ff);position:relative;overflow:hidden;border:1px solid rgba(12,40,80,0.04)}
    .gubby{
        position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:140px;height:140px;pointer-events:auto;cursor:pointer;
        -webkit-user-select: none; /* Safari */ -moz-user-select: none; /* Firefox */ -ms-user-select: none; /* IE 10+ */ user-select: none; /* Standard syntax */
        -webkit-user-drag: none; -khtml-user-drag: none; -moz-user-drag: none; -o-user-drag: none; user-drag: none;
    }
    .stats{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-top:12px}
    .stat{min-width:160px;background:white;border-radius:10px;padding:10px;border:1px solid rgba(12,40,80,0.04);text-align:center}
    .stat .label{font-size:12px;color:var(--muted)}
    .stat .value{font-weight:800;font-size:18px;margin-top:6px}
    .bar{height:12px;background:#eef6ff;border-radius:999px;margin-top:8px;overflow:hidden}
    .fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));transition:width .2s}
    body.room-mode .fill{background:linear-gradient(90deg,var(--room-accent),var(--room-accent2))}
    .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:10px}
    .right-col{display:flex;flex-direction:column;gap:12px}
    .member-list{display:flex;flex-direction:column;gap:8px}
    .modal-backdrop{position:fixed;inset:0;background:rgba(8,10,20,0.45);display:none;align-items:center;justify-content:center;z-index:999}
    .modal{width:92%;max-width:500px;background:white;border-radius:10px;padding:16px;box-shadow:0 30px 80px rgba(12,40,80,0.2);transform:translateY(8px);opacity:0;transition:all .18s}
    .modal.show{transform:none;opacity:1}
    .shop-grid{display:grid;grid-template-columns:repeat(auto-fill, minmax(220px, 1fr));gap:12px}
    .shop-card{border-radius:10px;padding:10px;background:linear-gradient(180deg,#fff,#f6fbff);border:1px solid rgba(12,40,80,0.04);display:flex;flex-direction:column;gap:8px;min-height:110px}
    .chat-window{height:360px;display:flex;flex-direction:column;border-radius:8px;overflow:hidden;border:1px solid rgba(12,40,80,0.06)}
    .chat-messages{flex:1;padding:10px;overflow:auto;background:#fbfdff}
    .chat-input{display:flex;gap:8px;padding:8px;border-top:1px solid rgba(12,40,80,0.04);background:white}
    .small{font-size:13px;color:var(--muted)}
    .modal-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:16px;}
    .shop-tabs{display:flex;gap:4px;border-bottom:1px solid #eee;margin-bottom:12px;}
    .shop-tab{padding:8px 12px;border-radius:8px 8px 0 0;cursor:pointer;font-weight:600;color:var(--muted);border:1px solid transparent;border-bottom:0;}
    .shop-tab.active{color:var(--accent);background:white;border-color:#eee;}
    .tab-content{display:none;}
    .tab-content.active{display:block;}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">G</div>
        <div>
          <h1 class="title">Gubby Clicker</h1>
          <div class="small">Clicker â€” Firestore multiplayer</div>
        </div>
      </div>
      <div class="top-actions">
        <div id="authArea" class="small">Not signed in</div>
        <button id="signInBtn" class="btn secondary">Sign in</button>
        <button id="upgradesOpenBtn" class="btn secondary">Upgrades</button>
        <button id="storeOpenBtn" class="btn">Store</button>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div class="house" id="house">
          <img id="gubbySprite" class="gubby" src="sprites/variants/default.png" draggable="false" onmousedown="return false;" alt="Gubby">
        </div>

        <div class="stats">
          <div class="stat"><div class="label">HUNGER</div><div class="value" id="hungerVal">0</div><div class="bar"><div id="hungerFill" class="fill" style="width:0%"></div></div></div>
          <div class="stat"><div class="label">THIRST</div><div class="value" id="thirstVal">0</div><div class="bar"><div id="thirstFill" class="fill" style="width:0%"></div></div></div>
          <div class="stat"><div class="label">ENERGY</div><div class="value" id="energyVal">0</div><div class="bar"><div id="energyFill" class="fill" style="width:0%"></div></div></div>
        </div>

        <div class="controls">
          <button id="feedBtn" class="btn">Feed</button>
          <button id="waterBtn" class="btn secondary">Give Water</button>
          <button id="colaBtn" class="btn secondary">Bloxy Cola</button>
          <button id="playBtn" class="btn secondary">Play</button>
          <button id="hostBtn" class="btn">Host</button>
          <button id="joinBtn" class="btn secondary">Join</button>
        </div>

        <div class="small" style="text-align:center;margin-top:8px">Click Gubby to get clicks. Singleplayer and multiplayer saves are separate.</div>
      </div>

      <div class="right-col">
        <div class="card">
          <strong>Account</strong>
          <div id="accountInfo" class="small" style="margin-top:8px">â€”</div>
        </div>
        
        <div class="card">
            <strong>Singleplayer</strong>
            <div class="small" style="margin-top:8px">Manage your local game save.</div>
            <div style="display:flex; gap:8px; margin-top:12px;">
                <button id="downloadSaveBtn" class="btn secondary">Download Save</button>
                <button id="singleplayerResetBtn" class="btn ghost">Reset Save</button>
            </div>
        </div>

        <div class="card" id="adminPanel" style="display:none">
          <strong>Admin</strong>
          <div class="small" style="margin-top:8px">Create variants (modifiers) â€” quick UI</div>
        </div>
      </div>
    </div>

    <footer class="small" style="text-align:center">Gubby Clicker â€” Firestore rooms Â· 50+ shop items</footer>
  </div>

  <!-- Multiplayer Modal -->
  <div class="modal-backdrop" id="multiplayerModal"><div class="modal" id="multiplayerBox">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3 style="margin:0">Multiplayer Room</h3>
        <button id="leaveRoom" class="btn ghost">Leave</button>
      </div>
      <div style="margin-top:16px;">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div><div class="small">Status</div><div id="connectionStatus" style="font-weight:800">Not connected</div></div>
            <div style="text-align:right">
              <div id="roomCode" style="font-weight:900; font-size: 20px;"></div>
              <div style="margin-top:6px"><button id="copyRoom" class="btn small ghost">Copy Code</button></div>
            </div>
          </div>

          <div style="margin-top:12px">
            <div class="small">Members</div>
            <div id="members" class="member-list" style="margin-top: 8px;"></div>
          </div>
          
          <div style="margin-top:12px; border-top: 1px solid #eee; padding-top: 12px;">
              <div class="small">Room Actions</div>
              <div style="display:flex; gap: 8px; margin-top: 8px;">
                <button id="chatOpenBtn" class="btn secondary">ðŸ’¬ Chat</button>
                <button id="resetBtn" class="btn ghost">Request Reset</button>
              </div>
              <div style="margin-top:8px"><div id="resetStatus" class="small"></div></div>
          </div>
      </div>
  </div></div>

  <!-- Upgrades Modal -->
  <div class="modal-backdrop" id="upgradesModal"><div class="modal" id="upgradesBox" style="max-width: 900px;">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h3 style="margin:0">Upgrades</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="small">Clicks: <span id="clickCounterUpgrades">0</span></div>
        <button id="closeUpgrades" class="btn secondary">Close</button>
      </div>
    </div>
    <div class="shop-tabs">
        <div class="shop-tab active" data-tab="upgrades-general">Upgrades</div>
        <div class="shop-tab" data-tab="upgrades-variants">Variants</div>
    </div>
    <div id="upgrades-general" class="tab-content active">
        <div id="upgradesGrid" class="shop-grid"></div>
    </div>
    <div id="upgrades-variants" class="tab-content">
        <div id="variantsGrid" class="shop-grid"></div>
    </div>
  </div></div>
  
  <!-- Convenience Store Modal -->
  <div class="modal-backdrop" id="storeModal"><div class="modal" id="storeBox" style="max-width: 900px;">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h3 style="margin:0">Convenience Store</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="small">Clicks: <span id="clickCounterStore">0</span></div>
        <button id="closeStore" class="btn secondary">Close</button>
      </div>
    </div>
    <div style="margin-top:12px">
      <div id="storeGrid" class="shop-grid"></div>
    </div>
  </div></div>


  <!-- Chat Modal -->
  <div class="modal-backdrop" id="chatModal"><div class="modal" id="chatBox">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h3 style="margin:0">Room Chat</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="small" id="chatRoomLabel"></div>
        <button id="closeChat" class="btn secondary">Close</button>
      </div>
    </div>

    <div style="margin-top:12px" class="chat-window">
      <div id="chatMessages" class="chat-messages"></div>
      <div class="chat-input">
        <input id="chatInput" placeholder="Say something..." style="flex:1;padding:10px;border-radius:8px;border:1px solid rgba(12,40,80,0.06)"/>
        <button id="chatSend" class="btn">Send</button>
        <button id="chatClear" class="btn ghost small">Clear</button>
      </div>
    </div>
  </div></div>

  <!-- Join Modal -->
  <div class="modal-backdrop" id="joinModal"><div class="modal" id="joinBox">
    <h3>Join Room</h3>
    <input id="joinCode" placeholder="4-letter code" style="padding:8px;width:180px;border-radius:6px;border:1px solid #ddd"/>
    <div class="modal-actions">
      <button id="joinConfirm" class="btn">Join</button>
      <button id="joinCancel" class="btn secondary">Cancel</button>
    </div>
  </div></div>
  
  <!-- Generic Notification/Confirmation Modal -->
  <div class="modal-backdrop" id="notificationModal"><div class="modal" id="notificationBox">
      <h3 id="notificationTitle" style="margin:0 0 10px 0;">Notification</h3>
      <p id="notificationMessage" style="margin:0;"></p>
      <div id="notificationActions" class="modal-actions">
      </div>
  </div></div>


  <!-- Firebase compat scripts -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script>
  // ================= CONFIG =================
  const firebaseConfig = {
    apiKey: "AIzaSyAai5V9VTtPnAdMoAhhVe94fobPOY25yf8",
    authDomain: "gubby-clicker.firebaseapp.com",
    projectId: "gubby-clicker",
    storageBucket: "gubby-clicker.firebasestorage.app",
    messagingSenderId: "255072290621",
    appId: "1:255072290621:web:9f80676beac50c0059a754",
    measurementId: "G-R3HFMPH5C4"
  };

  // ================= STATE =================
  const defaultState = {
    name:'Gubby',
    variant:'default.png',
    pos:{x:340,y:220},
    hunger:80, thirst:80, energy:100, alive:true,
    clicks:0, totalClicks:0,
    upgrades:{clickPower:1, autoClicks:0, multipliers:[]},
    backpack:{ food:5, water:5, cola:2 },
    lastUpdated: Date.now()
  };
  let state = loadLocalState(); // working copy
  let user = null, auth = null, db = null;
  let currentRoom = null, roomUnsub=null, membersUnsub=null, messagesUnsub=null;
  let myId = randomId(), writeTimer=null;
  const WRITE_DEBOUNCE_MS = 600;
  let variantsData = [];

  // ================= SHOP DATA =================
  const upgradesData = [
    {id:'clicker1', title:'Click Power +1', price:200, desc:'Increase click power'},
    {id:'auto1', title:'Auto-Clicker +1', price:800, desc:'+1 auto click'},
    {id:'laser_toy', title:'Laser Toy', price:480, desc:'Fun and energizing'},
    {id:'bowl2', title:'Silver Bowl', price:400, desc:'Better food efficiency'},
    {id:'microphone', title:'DJ Microphone', price:480, desc:'Music multiplier chance'},
    {id:'auto_feeder2', title:'Auto-Feeder Mk II', price:2400, desc:'+5 auto clicks'},
    {id:'bed', title:'Cozy Bed', price:350, desc:'Energy recovers faster'},
    {id:'mini_farm', title:'Mini Farm', price:2200, desc:'Generates food slowly'},
    {id:'garden', title:'Garden', price:750, desc:'Auto grow snacks'},
    {id:'neon_sign', title:'Neon Gubby Sign', price:700, desc:'Stylish'},
    {id:'lux_cushion', title:'Luxury Cushion', price:900, desc:'Comfort'},
    {id:'fountain', title:'Fountain', price:650, desc:'Relaxing water feature'},
    {id:'trainer', title:'Personal Trainer', price:1200, desc:'+2 energy during day'},
    {id:'fancy_plate', title:'Fancy Plate', price:1100, desc:'Fine dining'},
    {id:'mystic_hat', title:'Mystic Hat', price:1300, desc:'Looks mysterious'},
    {id:'zen_garden', title:'Zen Garden', price:1400, desc:'Relaxation'},
    {id:'orb', title:'Mystic Orb', price:4200, desc:'Weird energies'},
    {id:'quantum_seed', title:'Quantum Seed', price:5200, desc:'Grows unpredictable snacks'},
    {id:'time_clock', title:'Time Clock', price:12000, desc:'Time-warping clock'},
  ];
  const storeData = [
    {id:'burger', title:'Burger', price:25, desc:'Food +1'},
    {id:'waterbottle', title:'Water Bottle', price:20, desc:'Water +1'},
    {id:'ball', title:'Bouncy Ball', price:50, desc:'Play toy'},
    {id:'snackbox', title:'Snack Box', price:180, desc:'Mixed snacks'},
    {id:'soda_pack', title:'Cola Pack', price:350, desc:'+2 Cola'},
    {id:'plushie', title:'Plushie', price:200, desc:'Cute friend'},
    {id:'toy2', title:'Squeaky Toy', price:120, desc:'Play toy'},
    {id:'treats', title:'Treats (10)', price:300, desc:'Bulk snacks'},
  ];

  // ================= UTIL =================
  function el(id){ return document.getElementById(id); }
  function randomId(){ return Math.random().toString(36).slice(2,9); }
  function saveLocalState(){ localStorage.setItem('gubby_single_local', JSON.stringify(state)); }
  function loadLocalState(){ try{ const raw = localStorage.getItem('gubby_single_local'); if(raw) return JSON.parse(raw);}catch(e){} return JSON.parse(JSON.stringify(defaultState)); }
  function clamp(v){ return Math.max(0, Math.min(100, Math.round(v))); }
  
  function showNotification(message, title = 'Notification', buttons = [{ text: 'OK', class: 'btn' }]) {
    el('notificationTitle').textContent = title;
    el('notificationMessage').innerHTML = message;
    const actions = el('notificationActions');
    actions.innerHTML = '';
    
    const modal = el('notificationModal');
    
    buttons.forEach(btnInfo => {
        const button = document.createElement('button');
        button.textContent = btnInfo.text;
        button.className = btnInfo.class;
        button.onclick = () => {
            closeNotification();
            if (btnInfo.onClick) btnInfo.onClick();
        };
        actions.appendChild(button);
    });

    modal.style.display = 'flex';
    setTimeout(() => el('notificationBox').classList.add('show'), 10);
  }

  function closeNotification() {
      el('notificationBox').classList.remove('show');
      setTimeout(() => el('notificationModal').style.display = 'none', 180);
  }

  function applyUI(){
    el('hungerVal').textContent = Math.round(state.hunger);
    el('thirstVal').textContent = Math.round(state.thirst);
    el('energyVal').textContent = Math.round(state.energy);
    el('hungerFill').style.width = clamp(state.hunger) + '%';
    el('thirstFill').style.width = clamp(state.thirst) + '%';
    el('energyFill').style.width = clamp(state.energy) + '%';
    const clicks = state.totalClicks || 0;
    el('clickCounterUpgrades') && (el('clickCounterUpgrades').textContent = clicks);
    el('clickCounterStore') && (el('clickCounterStore').textContent = clicks);
    el('gubbySprite').src = 'sprites/variants/' + (state.variant || 'default.png');
    el('accountInfo').textContent = user ? (user.displayName || user.email) : 'Not signed in';
    el('authArea').textContent = user ? (user.displayName || user.email) : 'Not signed in';
  }

  // ================= FIREBASE INIT =================
  function initFirebase(){
    try{
      if(window.firebase && !db){
        firebase.initializeApp(firebaseConfig);
        auth = firebase.auth();
        db = firebase.firestore();

        auth.onAuthStateChanged(async u => {
          user = u;
          if(user){
            el('signInBtn').style.display = 'none';
            await loadSingleplayerFromServer().catch(()=>{});
          } else {
            el('signInBtn').style.display = 'inline-block';
            state = loadLocalState();
          }
          applyUI();
        });

        db.collection('variants').onSnapshot(snap => {
          variantsData = snap.docs.map(d => ({ id:d.id, ...d.data() }));
          renderVariantsShop();
        }, ()=>{});

      }
    }catch(e){
      console.error('init firebase failed', e);
      showNotification('Could not connect to game services.', 'Connection Error');
    }
  }
  initFirebase();

  // ================= AUTH UI =================
  el('signInBtn').addEventListener('click', async ()=>{
    try{
      if(!db) initFirebase();
      const provider = new firebase.auth.GoogleAuthProvider();
      await firebase.auth().signInWithPopup(provider);
    }catch(e){ showNotification('Sign-in failed: ' + (e.message||e)); }
  });

  // ================= SINGLEPLAYER SERVER SYNC =================
  async function loadSingleplayerFromServer(){
    if(!auth || !auth.currentUser) return;
    try{
      const ref = db.collection('users').doc(auth.currentUser.uid).collection('singleplayerState').doc('state');
      const snap = await ref.get();
      if(snap.exists){
        const remote = snap.data();
        state = Object.assign({}, state, remote);
        saveLocalState();
      } else {
        await ref.set(state);
      }
    }catch(e){ console.warn('load singleplayer failed', e); }
    applyUI();
  }
  async function saveSingleplayerToServer(){
    if(!auth || !auth.currentUser) return;
    try{
      const ref = db.collection('users').doc(auth.currentUser.uid).collection('singleplayerState').doc('state');
      await ref.set(state, { merge:true });
    }catch(e){ console.warn('save singleplayer failed', e); }
  }

  // ================= ROOM MANAGEMENT =================
  function genCode(){
    const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
    let s=''; for(let i=0;i<4;i++) s+=letters[Math.floor(Math.random()*letters.length)];
    return s;
  }

  async function hostRoom(){
    if(!auth || !auth.currentUser) { showNotification('Please sign in to host a room.'); return; }
    if(currentRoom) return showNotification('You are already in a room. Please leave the current room first.');
    for(let attempt=0; attempt<6; attempt++){
      const code = genCode();
      try{
        const ref = db.collection('rooms').doc(code);
        const snap = await ref.get();
        if(!snap.exists){
          currentRoom = code;
          await ref.set({ state: state, shopOwned: [], resetVotes: [], hostUid: auth.currentUser.uid, lastUpdated: Date.now() });
          await ref.collection('members').doc(auth.currentUser.uid).set({ uid: auth.currentUser.uid, name: auth.currentUser.displayName||auth.currentUser.email, joinedAt: Date.now() });
          listenRoom(code);
          listenMembers(code);
          applyRoomUI(true, code);
          showNotification(`You are now hosting room <strong>${code}</strong>.`, 'Room Hosted!');
          return;
        }
      }catch(e){ console.warn('host attempt failed', e); }
    }
    showNotification('Could not create a room at this time. Please try again.', 'Error');
  }

  async function joinRoom(code){
    if(!auth || !auth.currentUser) { showNotification('Please sign in to join a room.'); return; }
    if(currentRoom) return showNotification('You are already in a room.');
    code = (code||'').trim().toUpperCase();
    if(!code) return showNotification('Please enter a room code.');
    try{
      const ref = db.collection('rooms').doc(code);
      const snap = await ref.get();
      if(!snap.exists) return showNotification('That room could not be found.', 'Error');
      currentRoom = code;
      await ref.collection('members').doc(auth.currentUser.uid).set({ uid: auth.currentUser.uid, name: auth.currentUser.displayName||auth.currentUser.email, joinedAt: Date.now() });
      listenRoom(code);
      listenMembers(code);
      applyRoomUI(true, code);
      showNotification(`Successfully joined room <strong>${code}</strong>.`, 'Room Joined!');
    }catch(e){ showNotification('Join failed: ' + (e.message||e)); }
  }

  async function leaveRoom(){
    if(!currentRoom) return;
    const roomToLeave = currentRoom;
    
    if(roomUnsub){ roomUnsub(); roomUnsub=null; }
    if(membersUnsub){ membersUnsub(); membersUnsub=null; }
    if(messagesUnsub){ messagesUnsub(); messagesUnsub=null; }
    currentRoom = null;
    applyRoomUI(false, '');

    if(user) await loadSingleplayerFromServer().catch(()=>{}); else { state = loadLocalState(); applyUI(); }

    try{
      const ref = db.collection('rooms').doc(roomToLeave);
      if(auth && auth.currentUser) await ref.collection('members').doc(auth.currentUser.uid).delete().catch(()=>{});
      
      const membersSnap = await ref.collection('members').get();
      if(membersSnap.empty) {
          setTimeout(() => ref.delete().catch(e => console.warn("Failed to delete empty room", e)), 2000);
      }
    }catch(e){ console.warn('leave room db cleanup failed', e); }
  }

  function listenRoom(code){
    if(roomUnsub) roomUnsub();
    const ref = db.collection('rooms').doc(code);
    roomUnsub = ref.onSnapshot(doc => {
      if(!doc.exists){ 
          showNotification('The room was closed.', 'Room Closed');
          leaveRoom(); 
          return; 
      }
      const data = doc.data();
      if(!data) return;
      if(data.state) mergeRemoteState(data.state);
      window.__roomCache = data;
      updateResetStatus(data.resetVotes || []);
      renderUpgradesShop();
      renderVariantsShop();
      renderStore();
    }, err => console.warn('room listen err', err));
  }

  function listenMembers(code){
    if(membersUnsub) membersUnsub();
    const ref = db.collection('rooms').doc(code).collection('members');
    membersUnsub = ref.onSnapshot(snap => {
      const arr=[]; snap.forEach(d=>arr.push(d.data()));
      renderMembers(arr);
    }, err => console.warn('members listen err', err));
  }

  // ================= MERGE / WRITE SCHEDULING =================
  function scheduleWrite(){
    saveLocalState();
    applyUI();
    if(!currentRoom){
      if(user) saveSingleplayerToServer().catch(()=>{});
      return;
    }
    if(writeTimer) clearTimeout(writeTimer);
    writeTimer = setTimeout(()=> writeRoomNow(), WRITE_DEBOUNCE_MS);
  }

  function writeRoomNow(){
    if(!currentRoom) return;
    const ref = db.collection('rooms').doc(currentRoom);
    const payload = { state: state, from: myId, lastUpdated: Date.now() };
    ref.set(payload, { merge:true }).catch(e => console.warn('write failed', e));
  }

  function mergeRemoteState(remote){
    if(!remote) return;
    if(remote.totalClicks > (state.totalClicks||0)){
      state.totalClicks = remote.totalClicks;
      state.upgrades = remote.upgrades || state.upgrades;
      state.variant = remote.variant || state.variant;
    }
    state.backpack.food = Math.max(state.backpack.food||0, remote.backpack?.food||0);
    state.backpack.water = Math.max(state.backpack.water||0, remote.backpack?.water||0);
    state.backpack.cola = Math.max(state.backpack.cola||0, remote.backpack?.cola||0);
    state.hunger = Math.round((state.hunger + (remote.hunger||state.hunger))/2);
    state.thirst = Math.round((state.thirst + (remote.thirst||state.thirst))/2);
    state.energy = Math.round((state.energy + (remote.energy||state.energy))/2);
    saveLocalState(); applyUI();
  }
  
    // ================= SINGLEPLAYER ACTIONS =================
    el('singleplayerResetBtn').addEventListener('click', () => {
        showNotification('Are you sure you want to reset your single-player save? This cannot be undone.', 'Confirm Reset', [
            { text: 'Reset', class: 'btn', onClick: () => {
                state = JSON.parse(JSON.stringify(defaultState));
                localStorage.removeItem('gubby_single_owned');
                saveLocalState();
                if (user) saveSingleplayerToServer();
                applyUI();
                showNotification('Your single-player game has been reset.', 'Success');
            }},
            { text: 'Cancel', class: 'btn secondary' }
        ]);
    });

    el('downloadSaveBtn').addEventListener('click', () => {
        try {
            const saveData = JSON.stringify({ state: state, owned: JSON.parse(localStorage.getItem('gubby_single_owned') || '[]') }, null, 2);
            const blob = new Blob([saveData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gubby-save.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (e) {
            console.error('Failed to download save file', e);
            showNotification('Could not download save file.', 'Error');
        }
    });

  // ================= SHOPS UI & BUY =================
  function openModal(modalId, boxId) {
      el(modalId).style.display = 'flex';
      setTimeout(()=> el(boxId).classList.add('show'), 10);
  }
  function closeModal(modalId, boxId) {
      el(boxId).classList.remove('show');
      setTimeout(()=> el(modalId).style.display='none',180);
  }

  el('upgradesOpenBtn').addEventListener('click', ()=> { openModal('upgradesModal', 'upgradesBox'); renderUpgradesShop(); renderVariantsShop(); });
  el('closeUpgrades').addEventListener('click', ()=> closeModal('upgradesModal', 'upgradesBox'));
  el('storeOpenBtn').addEventListener('click', ()=> { openModal('storeModal', 'storeBox'); renderStore(); });
  el('closeStore').addEventListener('click', ()=> closeModal('storeModal', 'storeBox'));
  
  document.querySelectorAll('.shop-tab').forEach(tab => {
      tab.addEventListener('click', () => {
          document.querySelectorAll('.shop-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab).classList.add('active');
      });
  });

  function getOwnedItems() {
      if(currentRoom && window.__roomCache) return window.__roomCache.shopOwned || [];
      const raw = localStorage.getItem('gubby_single_owned');
      return raw ? JSON.parse(raw) : [];
  }

  function renderUpgradesShop(){
    const grid = el('upgradesGrid'); grid.innerHTML = '';
    const owned = getOwnedItems();
    upgradesData.forEach(item => {
      const card = document.createElement('div'); card.className='shop-card';
      const isOwned = owned.includes(item.id);
      card.innerHTML = `<div style="display:flex;justify-content:space-between"><div><strong>${item.title}</strong><div class="small">${item.desc}</div></div><div style="text-align:right"><div class="small">${item.price} âœ¨</div></div></div>
        <div style="display:flex;justify-content:flex-end;align-items:center;margin-top:8px"><div><button class="btn small ${isOwned?'ghost':''}" ${isOwned?'disabled':''}>${isOwned?'Owned':'Buy'}</button></div></div>`;
      const btn = card.querySelector('button');
      btn.addEventListener('click', ()=> buyItem(item, 'upgrade'));
      grid.appendChild(card);
    });
  }
  
  function renderVariantsShop() {
    const grid = el('variantsGrid'); grid.innerHTML = '';
    const owned = getOwnedItems();
    variantsData.forEach(item => {
      const card = document.createElement('div'); card.className='shop-card';
      const isOwned = owned.includes(item.id);
      card.innerHTML = `<div style="display:flex;justify-content:space-between"><div><strong>${item.title}</strong><div class="small">${item.desc}</div></div><div style="text-align:right"><div class="small">${item.price} âœ¨</div></div></div>
        <div style="display:flex;justify-content:flex-end;align-items:center;margin-top:8px"><div><button class="btn small ${isOwned?'ghost':''}" ${isOwned?'disabled':''}>${isOwned?'Owned':'Buy'}</button></div></div>`;
      const btn = card.querySelector('button');
      btn.addEventListener('click', ()=> buyItem(item, 'variant'));
      grid.appendChild(card);
    });
  }
  
  function renderStore(){
    const grid = el('storeGrid'); grid.innerHTML = '';
    storeData.forEach(item => {
      const card = document.createElement('div'); card.className='shop-card';
      card.innerHTML = `<div style="display:flex;justify-content:space-between"><div><strong>${item.title}</strong><div class="small">${item.desc}</div></div><div style="text-align:right"><div class="small">${item.price} âœ¨</div></div></div>
        <div style="display:flex;justify-content:flex-end;align-items:center;margin-top:8px"><div><button class="btn small">Buy</button></div></div>`;
      const btn = card.querySelector('button');
      btn.addEventListener('click', ()=> buyItem(item, 'consumable'));
      grid.appendChild(card);
    });
  }

  async function buyItem(item, type){
    if (state.totalClicks < item.price) return showNotification('Not enough clicks.');

    if (type === 'consumable') {
        state.totalClicks -= item.price;
        if(item.id === 'burger') state.backpack.food = (state.backpack.food||0)+1;
        if(item.id === 'waterbottle') state.backpack.water = (state.backpack.water||0)+1;
        if(item.id === 'soda_pack') state.backpack.cola = (state.backpack.cola||0)+2;
        // ... other consumables
        scheduleWrite();
        showNotification(`Purchased ${item.title}`);
        return;
    }
    
    // Logic for one-time purchases (upgrades and variants)
    if(!currentRoom){
      const owned = getOwnedItems();
      if (owned.includes(item.id)) return showNotification("You already own this item.");
      state.totalClicks -= item.price;
      
      if (type === 'variant') state.variant = item.id;
      if (item.id === 'clicker1') state.upgrades.clickPower = (state.upgrades.clickPower||1)+1;
      
      owned.push(item.id);
      localStorage.setItem('gubby_single_owned', JSON.stringify(owned));
      scheduleWrite();
      showNotification(`Purchased (singleplayer): ${item.title}`);
      renderUpgradesShop();
      renderVariantsShop();
      return;
    }

    if(!user) return showNotification('Sign in to buy in multiplayer.');
    const roomRef = db.collection('rooms').doc(currentRoom);
    try{
      await db.runTransaction(async tx => {
        const snap = await tx.get(roomRef);
        if(!snap.exists) throw new Error('Room missing');
        const data = snap.data();
        const owned = data.shopOwned || [];
        if(owned.includes(item.id)) throw new Error('Already owned by someone in the room');
        const roomState = data.state || {};
        const totalClicks = Number(roomState.totalClicks || 0);
        if(totalClicks < item.price) throw new Error('Not enough room clicks');
        
        const newOwned = owned.concat([item.id]);
        const newState = Object.assign({}, roomState);
        newState.totalClicks = totalClicks - item.price;

        if (type === 'variant') newState.variant = item.id;
        if (item.id === 'clicker1') newState.upgrades = Object.assign({}, newState.upgrades || {}, { clickPower: (newState.upgrades?.clickPower||1)+1 });

        tx.update(roomRef, { shopOwned: newOwned, state: newState, lastUpdated: Date.now() });
      });
      showNotification('Purchased ' + item.title);
    }catch(e){
      console.warn('purchase failed', e);
      showNotification('Purchase failed: ' + (e.message || e));
    }
  }

  // ================= CHAT =================
  el('chatOpenBtn').addEventListener('click', ()=>openModal('chatModal', 'chatBox'));
  el('chatSend').addEventListener('click', sendChatMessage);
  el('closeChat').addEventListener('click', ()=>closeModal('chatModal', 'chatBox'));
  el('chatClear').addEventListener('click', async ()=>{
    if(!currentRoom) return showNotification('Join a room first.');
    showNotification('Are you sure you want to clear the chat for everyone?', 'Confirm Clear', [
        { text: 'Clear Chat', class: 'btn', onClick: async () => {
            try{
              const msgsRef = db.collection('rooms').doc(currentRoom).collection('messages');
              const snap = await msgsRef.get();
              const batch = db.batch();
              snap.forEach(d => batch.delete(d.ref));
              await batch.commit();
              showNotification('Chat cleared');
            }catch(e){ console.warn('clear chat failed', e); showNotification('Clear failed: ' + (e.message||e)); }
        }},
        { text: 'Cancel', class: 'btn secondary' }
    ]);
  });

  function listenMessages(code){
    if(messagesUnsub) messagesUnsub();
    const msgsRef = db.collection('rooms').doc(code).collection('messages').orderBy('createdAt','asc').limit(500);
    messagesUnsub = msgsRef.onSnapshot(snap => {
      const container = el('chatMessages'); container.innerHTML = '';
      snap.forEach(doc => {
        const m = doc.data();
        const div = document.createElement('div');
        div.style.marginBottom = '8px';
        div.innerHTML = `<div style="font-weight:700">${escapeHtml(m.name||m.uid)}</div><div class="small">${escapeHtml(m.text)}</div><div style="font-size:11px;color:var(--muted)">${new Date(m.createdAt).toLocaleTimeString()}</div>`;
        container.appendChild(div);
      });
      container.scrollTop = container.scrollHeight;
    }, err => {
      console.warn('messages listen err', err);
      showNotification('Chat listen error: ' + (err.message||err));
    });
  }

  async function sendChatMessage(){
    if(!currentRoom) return showNotification('Join a room first');
    if(!user) return showNotification('Sign in to chat');
    const text = (el('chatInput').value || '').trim();
    if(!text) return;
    try{
      await db.collection('rooms').doc(currentRoom).collection('messages').add({ uid: auth.currentUser.uid, name: auth.currentUser.displayName || auth.currentUser.email || 'You', text, createdAt: Date.now() });
      el('chatInput').value = '';
    }catch(e){
      console.warn('send chat failed', e);
      showNotification('Send chat failed: ' + (e.message||e) + '\nCheck Firestore rules.');
    }
  }

  // ================= RESET =================
  el('resetBtn').addEventListener('click', ()=> {
    if(!currentRoom) return showNotification('Join a room first');
    if(!auth || !auth.currentUser) return showNotification('Sign in to request reset');
    showNotification('Request a room reset? All members must agree.', 'Confirm Reset', [
        { text: 'Request Reset', class: 'btn', onClick: requestResetVote },
        { text: 'Cancel', class: 'btn secondary' }
    ]);
  });

  async function requestResetVote(){
    const roomRef = db.collection('rooms').doc(currentRoom);
    try{
      await db.runTransaction(async tx => {
        const snap = await tx.get(roomRef);
        if(!snap.exists) throw new Error('Room missing');
        const data = snap.data();
        const resetSet = new Set(data.resetVotes || []);
        resetSet.add(auth.currentUser.uid);
        const membersSnap = await roomRef.collection('members').get();
        const memberIds = []; membersSnap.forEach(m => memberIds.push(m.id));
        if(memberIds.length === 0 || memberIds.every(id => resetSet.has(id))){
          tx.update(roomRef, { state: defaultState, resetVotes: [], shopOwned: [], lastUpdated: Date.now() });
        } else {
          tx.update(roomRef, { resetVotes: Array.from(resetSet), lastUpdated: Date.now() });
        }
      });
      showNotification('Your vote was recorded. The room will reset when all members agree.');
    }catch(e){
      console.warn('reset tx failed', e);
      showNotification('Reset failed: ' + (e.message||e));
    }
  }

  async function updateResetStatus(votes){
    if(!currentRoom) { el('resetStatus').textContent = ''; return; }
    try{
      const membersSnap = await db.collection('rooms').doc(currentRoom).collection('members').get();
      const count = membersSnap.size;
      el('resetStatus').textContent = `Reset votes: ${(votes||[]).length} / ${count}`;
    }catch(e){ el('resetStatus').textContent = `Reset votes: ${(votes||[]).length}`; }
  }

  // ================= MEMBERS UI =================
  function renderMembers(arr){
    const wrap = el('members'); wrap.innerHTML = '';
    if (arr.length === 0) {
        wrap.innerHTML = `<div class="small">Just you in here... for now.</div>`;
        return;
    }
    arr.forEach(m=>{
      const d = document.createElement('div'); d.className='small'; d.style.padding='6px'; d.style.borderRadius='6px'; d.style.border='1px solid rgba(12,40,80,0.04)'; d.textContent = m.name || m.uid;
      wrap.appendChild(d);
    });
  }

  // ================= MOVEMENT / DECAY / LOOP =================
  el('gubbySprite').addEventListener('click', ()=> {
    if(!state.alive) return;
    const mult = (state.upgrades.multipliers || []).reduce((a,b)=>a*b,1) || 1;
    const power = (state.upgrades.clickPower || 1) * mult;
    state.clicks += power; state.totalClicks += power;
    state.hunger = Math.max(0, state.hunger - 0.1);
    state.thirst = Math.max(0, state.thirst - 0.2);
    scheduleWrite();
  });

  el('feedBtn').addEventListener('click', ()=> { if(state.backpack.food>0){ state.backpack.food--; state.hunger = Math.min(100, state.hunger+25); scheduleWrite(); } else showNotification('You have no food!');});
  el('waterBtn').addEventListener('click', ()=> { if(state.backpack.water>0){ state.backpack.water--; state.thirst = Math.min(100, state.thirst+25); scheduleWrite(); } else showNotification('You have no water!');});
  el('colaBtn').addEventListener('click', ()=> { if(state.backpack.cola>0){ state.backpack.cola--; state.energy = Math.min(100, state.energy+50); scheduleWrite(); } else showNotification('You have no Bloxy Cola!');});
  el('playBtn').addEventListener('click', ()=> { state.energy = Math.min(100, state.energy+8); scheduleWrite(); });

  function wander(){
    if(!state.alive) return;
    const margin = 80;
    const newX = Math.random()*(el('house').clientWidth - margin*2) + margin;
    const newY = Math.random()*(el('house').clientHeight - margin*2) + margin;
    state.pos.x = newX; state.pos.y = newY;
    state.energy = Math.max(0, state.energy - 0.2);
    el('gubbySprite').style.left = newX + 'px'; el('gubbySprite').style.top = newY + 'px';
    scheduleWrite();
  }
  setInterval(wander, 4000);

  setInterval(()=>{
    if(!state.alive) return;
    state.hunger = Math.max(0, state.hunger - 0.5);
    state.thirst = Math.max(0, state.thirst - 0.6);
    const hour = (new Date()).getHours();
    if(hour>=22||hour<7) state.energy = Math.min(100, state.energy + 1); else state.energy = Math.max(0, state.energy - 0.2);
    if(state.hunger === 0 || state.thirst === 0) state.energy = Math.max(0, state.energy - 1);
    if(state.upgrades.autoClicks > 0) { state.clicks += state.upgrades.autoClicks; state.totalClicks += state.upgrades.autoClicks; }
    if(state.energy <= 0 || state.hunger <= 0 || state.thirst <= 0){
      state.alive = false; scheduleWrite(); showGameOver();
    }
    scheduleWrite();
  }, 5000);

  // ================= GAME OVER UI =================
  function showGameOver(){ showNotification('Gubby has run out of health! In single-player, you can reset your save. In multiplayer, ask the room to vote for a reset.', 'Game Over'); }
  
  // ================= HELPERS =================
  function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]); }

  // ================= UI BINDINGS =================
  el('hostBtn').addEventListener('click', ()=> { initFirebase(); hostRoom(); });
  el('joinBtn').addEventListener('click', ()=> openModal('joinModal', 'joinBox'));
  el('joinCancel').addEventListener('click', ()=> closeModal('joinModal', 'joinBox'));
  el('joinConfirm').addEventListener('click', ()=> { const code = el('joinCode').value.trim(); closeModal('joinModal', 'joinBox'); if(code) joinRoom(code); });
  el('leaveRoom').addEventListener('click', ()=> { 
      showNotification('Are you sure you want to leave the room?', 'Confirm Leave', [
          { text: 'Leave', class: 'btn', onClick: leaveRoom },
          { text: 'Stay', class: 'btn secondary' }
      ]);
  });
  el('copyRoom').addEventListener('click', ()=> { if(!currentRoom) return; navigator.clipboard?.writeText(currentRoom).then(()=>showNotification('Room code copied!'), ()=>showNotification('Could not copy code.')); });

  // ================= ROOM UI APPLY =================
  function applyRoomUI(connected, code){
    const multiplayerModal = el('multiplayerModal');
    if(connected){
      document.body.classList.add('room-mode');
      el('connectionStatus').textContent = 'Connected';
      el('roomCode').textContent = code;
      openModal('multiplayerModal', 'multiplayerBox');
      listenMessages(code);
    } else {
      document.body.classList.remove('room-mode');
      closeModal('multiplayerModal', 'multiplayerBox');
    }
  }

  // ================= CLEANUP ON UNLOAD =================
  window.addEventListener('beforeunload', async ()=>{
    try{
      if(currentRoom && db && auth && auth.currentUser){
        await db.collection('rooms').doc(currentRoom).collection('members').doc(auth.currentUser.uid).delete().catch(()=>{});
        const members = await db.collection('rooms').doc(currentRoom).collection('members').limit(1).get();
        if(members.empty) await db.collection('rooms').doc(currentRoom).delete().catch(()=>{});
      }
    }catch(e){}
  });

  applyUI();
  window.GubbyClicker = { state, saveLocalState, loadLocalState, hostRoom, joinRoom, leaveRoom };
  </script>
</body>
</html>
