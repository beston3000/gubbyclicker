<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gubby Clicker</title>

<!--
  Gubby Clicker - Single-file standalone game
  - Sprites at ./sprites/variants/
  - Sound at ./sounds/merp.mp3
  - Optional Firestore admin (set firebaseConfig below)
  Notes:
  - P2P uses manual signaling (copy/paste invites). Messages include seq numbers for basic replay protection.
  - Game Over is synchronized across peers.
-->

<style>
:root{
  --bg:#eef6ff; --card:#fff; --accent:#4d7cff; --accent-2:#6b8cff; --muted:#6b7280;
  --glass: rgba(255,255,255,0.65);
}
*{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Arial}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#eaf5ff,#f8fbff);display:flex;align-items:center;justify-content:center}
.wrap{width:1100px;background:var(--card);border-radius:14px;box-shadow:0 18px 60px rgba(10,20,40,0.12);overflow:hidden;display:grid;grid-template-rows:auto 1fr;animation:appear .35s ease}
@keyframes appear{from{transform:translateY(8px);opacity:0}to{transform:none;opacity:1}}
header{display:flex;align-items:center;justify-content:space-between;padding:14px 20px;border-bottom:1px solid rgba(12,40,80,0.03)}
.header-left{display:flex;align-items:center;gap:12px}
.logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;color:white;font-weight:700;box-shadow:0 6px 18px rgba(75,110,255,0.12);transform:translateZ(0)}
h1{font-size:18px;margin:0}
.top-controls{display:flex;gap:10px;align-items:center}
.small-muted{font-size:13px;color:var(--muted)}

/* main layout */
.main{display:grid;grid-template-columns:1fr 360px;gap:18px;padding:18px}
.game-card{background:linear-gradient(180deg,#ffffff,#f4fbff);border-radius:12px;padding:14px;display:flex;flex-direction:column;align-items:center;gap:12px;box-shadow:inset 0 -10px 30px rgba(100,140,255,0.02)}
.house{width:620px;height:460px;border-radius:10px;background:linear-gradient(180deg,#ffffff,#eaf8ff);position:relative;overflow:hidden;border:1px solid rgba(12,40,80,0.05)}
.gubby-sprite{position:absolute;transform:translate(-50%,-50%);width:110px;height:110px;transition:transform .35s linear,left .45s linear, top .45s linear;pointer-events:auto;z-index:30;will-change:transform,left,top;display:block}
/* gentle floating animation */
@keyframes floaty{0%{transform:translate(-50%,-50%) translateY(0)}50%{transform:translate(-50%,-50%) translateY(-6px)}100%{transform:translate(-50%,-50%) translateY(0)}}
.gubby-float{animation:floaty 3s ease-in-out infinite}

/* HUD */
.hud{display:flex;gap:12px;width:100%;justify-content:center}
.stat{background:var(--card);border-radius:10px;padding:10px 14px;border:1px solid rgba(12,40,80,0.04);min-width:150px;text-align:center;box-shadow:0 6px 18px rgba(80,110,255,0.03)}
.stat .label{font-size:12px;color:var(--muted)}
.stat .value{font-weight:700;font-size:18px;margin-top:6px}

/* controls row */
.controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:6px}
button{padding:10px 12px;border-radius:10px;border:0;background:var(--accent);color:white;font-weight:700;cursor:pointer;box-shadow:0 8px 18px rgba(75,110,255,0.08);transition:transform .12s ease,box-shadow .12s ease}
button.secondary{background:white;color:var(--accent);border:1px solid rgba(75,110,255,0.12);font-weight:700}
button:hover{transform:translateY(-3px);box-shadow:0 18px 36px rgba(75,110,255,0.12)}

/* right column panels */
.right-col{display:flex;flex-direction:column;gap:12px}
.panel{background:white;border-radius:10px;padding:12px;border:1px solid rgba(12,40,80,0.04)}
.compact{font-size:13px;color:var(--muted)}
.backpack{display:flex;gap:8px;align-items:center}
.bp-item{display:flex;flex-direction:column;align-items:center;font-size:13px;color:var(--muted);padding:6px 8px;border-radius:8px;border:1px solid rgba(12,40,80,0.03);background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(250,250,255,0.95))}
.bp-qty{font-weight:800;color:#111}

/* variants list */
.variants-list{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.variant-item{padding:8px;border-radius:8px;border:1px solid rgba(12,40,80,0.03);cursor:pointer;display:flex;justify-content:space-between;align-items:center}
.variant-item:hover{background:linear-gradient(180deg,rgba(245,250,255,0.6),white)}

/* modal overlay & modal */
.modal-backdrop{position:fixed;inset:0;background:rgba(10,14,40,0.45);display:none;align-items:center;justify-content:center;z-index:200}
.modal{width:680px;background:white;border-radius:12px;padding:18px;box-shadow:0 30px 80px rgba(12,40,80,0.35);transform:translateY(20px);opacity:0;transition:all .28s cubic-bezier(.2,.9,.2,1)}
.modal.show{transform:translateY(0);opacity:1}
.shop-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
.shop-item{border-radius:10px;border:1px solid rgba(12,40,80,0.04);padding:12px;display:flex;flex-direction:column;gap:8px;transition:transform .12s}
.shop-item:hover{transform:translateY(-6px)}
.shop-item .title{font-weight:700}
.shop-item .price{color:var(--muted);font-size:13px}

/* Game Over modal */
.gameover-backdrop{position:fixed;inset:0;background:rgba(8,10,20,0.6);display:none;align-items:center;justify-content:center;z-index:400}
.gameover-box{background:white;padding:28px;border-radius:12px;text-align:center;box-shadow:0 30px 80px rgba(12,40,80,0.45);transform:scale(.94);opacity:0;transition:all .25s}
.gameover-box.show{transform:scale(1);opacity:1}

/* small text */
.small-muted{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap" id="app">
  <header>
    <div class="header-left">
      <div class="logo">G</div>
      <div><h1>Gubby Clicker</h1><div class="small-muted">Roblox-themed clicker — P2P multiplayer</div></div>
    </div>
    <div class="top-controls">
      <div id="backpackUI" class="backpack">
        <div class="bp-item"><div class="bp-qty" id="bpFood">0</div><div class="compact">Food</div></div>
        <div class="bp-item"><div class="bp-qty" id="bpWater">0</div><div class="compact">Water</div></div>
        <div class="bp-item"><div class="bp-qty" id="bpCola">0</div><div class="compact">Cola</div></div>
      </div>
      <div class="small-muted" id="authArea">Not signed in</div>
      <button id="googleSignIn" class="secondary">Sign in</button>
      <button id="shopBtn" class="secondary">Shop</button>
    </div>
  </header>

  <div class="main">
    <div class="game-card">
      <div class="house" id="house">
        <img id="gubbySprite" class="gubby-sprite gubby-float" src="sprites/variants/default.png" style="left:260px;top:210px" draggable="false" />
      </div>

      <div class="hud">
        <div class="stat"><div class="label">HUNGER</div><div class="value" id="hungerVal">0</div></div>
        <div class="stat"><div class="label">THIRST</div><div class="value" id="thirstVal">0</div></div>
        <div class="stat"><div class="label">ENERGY</div><div class="value" id="energyVal">0</div></div>
      </div>

      <div class="controls">
        <button id="feedBtn">Feed</button>
        <button id="waterBtn" class="secondary">Give Water</button>
        <button id="colaBtn" class="secondary">Bloxy Cola</button>
        <button id="playBtn" class="secondary">Play</button>
        <button id="inviteBtn" class="secondary">Create Invite</button>
        <button id="pasteInviteBtn" class="secondary">Join Invite</button>
      </div>
      <div class="small-muted">Click Gubby to get clicks. All actions sync to other players.</div>
    </div>

    <div class="right-col">
      <div class="panel">
        <strong>Connection</strong>
        <div style="margin-top:8px" class="compact">Manual P2P signaling (no server). Create an invite, share it with friends, process their answer.</div>
        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="createInviteShort" class="secondary">Create Invite</button>
          <button id="copyInviteBtn" class="secondary">Copy Invite</button>
          <button id="disconnectBtn">Disconnect</button>
        </div>
        <textarea id="inviteOut" placeholder="Invite / Answer appears here" style="margin-top:8px"></textarea>
        <textarea id="inviteIn" placeholder="Paste invite/answer here" style="margin-top:8px"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="processInvite" class="secondary">Process Invite</button>
          <button id="processAnswer" class="secondary">Paste Answer</button>
        </div>
      </div>

      <div class="panel">
        <strong>Account</strong>
        <div id="accountInfo" class="compact" style="margin-top:8px">—</div>
      </div>

      <div class="panel">
        <strong>Variants</strong>
        <div id="variantsList" class="variants-list"></div>
      </div>

      <div class="panel admin-panel" id="adminPanel" style="display:none">
        <strong>Admin</strong>
        <div style="margin-top:8px" class="compact">
          <label>Variant ID</label><input id="variantId" type="text" placeholder="LavaGubby"><br>
          <label>File name</label><input id="variantFile" type="text" placeholder="lava.png"><br>
          <label>Price</label><input id="variantPrice" type="number" value="500"><br>
          <label>Attributes (json)</label><input id="variantAttrs" type="text" placeholder='{"clickMultiplier":1.5}'><br>
          <div style="display:flex;gap:8px;margin-top:8px"><button id="createVariantBtn">Create Variant</button><button id="refreshVariants">Refresh</button></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Shop modal -->
<div class="modal-backdrop" id="shopModal" role="dialog" aria-hidden="true">
  <div class="modal" id="shopBox">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h3 style="margin:0">Shop</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="compact">Clicks: <span id="clicksCounter">0</span></div>
        <button id="closeShop" class="secondary">Close</button>
      </div>
    </div>
    <div class="shop-grid" id="shopGrid"></div>
  </div>
</div>

<!-- Game Over modal -->
<div class="gameover-backdrop" id="gameOverBackdrop">
  <div class="gameover-box" id="gameOverBox">
    <h2>Game Over</h2>
    <p class="compact">Gubby has reached 0 in Hunger, Thirst, or Energy.</p>
    <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
      <button id="restartBtn">Restart For All</button>
      <button id="closeGameOver" class="secondary">Close</button>
    </div>
  </div>
</div>

<!-- Firebase (optional, loaded when needed) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<script>
/* ================= CONFIG ================= */
const firebaseConfig = {
  apiKey: "AIzaSyAai5V9VTtPnAdMoAhhVe94fobPOY25yf8",
  authDomain: "gubby-clicker.firebaseapp.com",
  projectId: "gubby-clicker",
  storageBucket: "gubby-clicker.firebasestorage.app",
  messagingSenderId: "255072290621",
  appId: "1:255072290621:web:9f80676beac50c0059a754",
  measurementId: "G-R3HFMPH5C4"
};
const SPRITE_BASE_PATH = "sprites/variants/";
const SOUND_BASE_PATH  = "sounds/"; // merp.mp3 here

/* ============== STATE ============== */
const defaultState = {
  name:'Gubby',
  variant:'default.png',
  pos:{x:260,y:210},
  hunger:80, thirst:80, energy:100, alive:true,
  clicks:0, totalClicks:0,
  upgrades:{clickPower:1, autoClicks:0, multipliers:[]},
  backpack:{ food:5, water:5, cola:2 },
  // sequence counter to help merging
  lastUpdated: Date.now()
};
let state = loadState();
let user = null;
let auth = null;
let db = null;

/* UI refs */
const gubbySprite = document.getElementById('gubbySprite');
const hungerVal = document.getElementById('hungerVal'), thirstVal = document.getElementById('thirstVal'), energyVal = document.getElementById('energyVal');
const bpFood = document.getElementById('bpFood'), bpWater = document.getElementById('bpWater'), bpCola = document.getElementById('bpCola');
const clicksCounter = document.getElementById('clicksCounter');
const shopModal = document.getElementById('shopModal'), shopBox = document.getElementById('shopBox'), shopGrid = document.getElementById('shopGrid');

/* peer messaging security: per-sender sequence numbers */
const peerSeq = {}; // peerId -> last seq received
let localSeq = 0;
let myPeerId = randomId();

/* WebAudio setup for merp with pitch jitter */
let audioCtx = null, merpBuffer = null;
async function loadMerp(){
  try{
    audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
    const res = await fetch(SOUND_BASE_PATH+'merp.mp3');
    if(!res.ok){ console.warn('merp missing at', SOUND_BASE_PATH+'merp.mp3'); merpBuffer = null; return; }
    const ab = await res.arrayBuffer();
    merpBuffer = await audioCtx.decodeAudioData(ab);
  }catch(e){ console.warn('loadMerp fail', e); merpBuffer = null; }
}
loadMerp();

function playMerp(){
  if(merpBuffer && audioCtx){
    const src = audioCtx.createBufferSource();
    src.buffer = merpBuffer;
    const jitter = (Math.random()*0.3) - 0.15; // -0.15 .. +0.15
    src.playbackRate.value = 1 + jitter;
    src.connect(audioCtx.destination);
    try{ src.start(0); }catch(e){}
  } else {
    try{ new Audio(SOUND_BASE_PATH+'merp.mp3').play().catch(()=>{}); }catch(e){}
  }
}

/* ============= UTIL ============== */
function el(id){ return document.getElementById(id); }
function randomId(){ return Math.random().toString(36).slice(2,9); }
function saveState(){ state.lastUpdated = Date.now(); localStorage.setItem('gubby_clicker_v1', JSON.stringify(state)); }
function loadState(){ try{ const raw = localStorage.getItem('gubby_clicker_v1'); if(raw) return JSON.parse(raw);}catch(e){} return JSON.parse(JSON.stringify(defaultState)); }
function applyUI(){ hungerVal.textContent = Math.round(state.hunger); thirstVal.textContent = Math.round(state.thirst); energyVal.textContent = Math.round(state.energy);
  bpFood.textContent = state.backpack.food; bpWater.textContent = state.backpack.water; bpCola.textContent = state.backpack.cola;
  clicksCounter.textContent = state.totalClicks; gubbySprite.src = SPRITE_BASE_PATH + state.variant;
  if(state.pos && typeof state.pos.x === 'number') gubbySprite.style.left = state.pos.x + 'px';
  if(state.pos && typeof state.pos.y === 'number') gubbySprite.style.top = state.pos.y + 'px';
  el('authArea').textContent = user ? (user.displayName || user.email || user.uid) : 'Not signed in';
}
applyUI();

/* prevent click glitch: ensure pointer-events and z-index */
gubbySprite.style.pointerEvents = 'auto';
gubbySprite.style.zIndex = 50;

/* ============= Shop modal & UI ============= */
const builtinShop = [
  {id:'click1', title:'Click Power +1', price:200, apply:()=>{ if(state.totalClicks<200) return alert('Not enough clicks'); state.upgrades.clickPower+=1; state.totalClicks-=200; }},
  {id:'auto1', title:'Auto Clicker +1', price:800, apply:()=>{ if(state.totalClicks<800) return alert('Not enough clicks'); state.upgrades.autoClicks+=1; state.totalClicks-=800; }},
  {id:'foodpack', title:'Food Pack +5', price:150, apply:()=>{ if(state.totalClicks<150) return alert('Not enough clicks'); state.backpack.food+=5; state.totalClicks-=150; }},
  {id:'waterpack', title:'Water +5', price:150, apply:()=>{ if(state.totalClicks<150) return alert('Not enough clicks'); state.backpack.water+=5; state.totalClicks-=150; }},
  {id:'colapack', title:'Bloxy Cola +2', price:300, apply:()=>{ if(state.totalClicks<300) return alert('Not enough clicks'); state.backpack.cola+=2; state.totalClicks-=300; }}
];

function openShop(items){ shopModal.style.display='flex'; setTimeout(()=>shopBox.classList.add('show'),10); renderShop(items); }
function closeShop(){ shopBox.classList.remove('show'); setTimeout(()=>shopModal.style.display='none',240); }

function renderShop(items){
  shopGrid.innerHTML = '';
  const list = items || builtinShop;
  list.forEach(it=>{
    const div = document.createElement('div'); div.className='shop-item';
    div.innerHTML = `<div class="title">${it.title}</div><div class="price">Price: ${it.price} clicks</div><div style="margin-top:8px"><button class="buy">Buy</button></div>`;
    div.querySelector('.buy').addEventListener('click', ()=>{
      if(state.totalClicks < it.price) return alert('Not enough clicks');
      it.apply();
      syncLocalAndPeers();
      applyUI();
      // broadcast purchase action
      broadcast({ t:'action', action:{ type:'purchase', id:it.id, price:it.price, by:myPeerId }, seq:++localSeq, from:myPeerId });
      alert('Purchased!');
    });
    shopGrid.appendChild(div);
  });
}

/* modal close wiring */
el('shopBtn').addEventListener('click', ()=> openShop());
el('closeShop').addEventListener('click', closeShop);

/* ============= Game & Actions ============= */
/* click Gubby locally: play sound, add clicks, broadcast */
function clickGubbyLocal(){
  if(!state.alive) return;
  // ensure audio context is resumed on user gesture
  if(audioCtx && audioCtx.state === 'suspended'){ audioCtx.resume().catch(()=>{}); }
  const mult = state.upgrades.multipliers.reduce((a,b)=>a*b,1) || 1;
  const power = (state.upgrades.clickPower || 1) * mult;
  state.clicks += power; state.totalClicks += power;
  state.hunger = Math.max(0, state.hunger - 0.1);
  state.thirst = Math.max(0, state.thirst - 0.2);
  playMerp();
  broadcast({ t:'action', action:{ type:'click', value:power, by:myPeerId }, seq:++localSeq, from:myPeerId });
  syncLocalAndPeers();
}
gubbySprite.addEventListener('click', ()=> clickGubbyLocal());

/* Use backpack item */
function useBackpack(type){
  if(!state.alive) return;
  if(!state.backpack[type] || state.backpack[type] <= 0) return alert('No item in backpack');
  // consume locally and apply
  state.backpack[type] -= 1;
  if(type === 'food') state.hunger = Math.min(100, state.hunger + 25);
  if(type === 'water') state.thirst = Math.min(100, state.thirst + 25);
  if(type === 'cola') state.energy = Math.min(100, state.energy + 50);
  broadcast({ t:'action', action:{ type:'use_item', item:type, by:myPeerId, count: state.backpack[type] }, seq:++localSeq, from:myPeerId });
  syncLocalAndPeers();
}
el('feedBtn').addEventListener('click', ()=> useBackpack('food'));
el('waterBtn').addEventListener('click', ()=> useBackpack('water'));
el('colaBtn').addEventListener('click', ()=> useBackpack('cola'));
el('playBtn').addEventListener('click', ()=> { state.energy = Math.min(100, state.energy + 8); broadcast({ t:'action', action:{ type:'play', by:myPeerId }, seq:++localSeq, from:myPeerId }); syncLocalAndPeers(); });

/* movement drains energy when wander occurs */
function wander(){
  if(!state.alive) return;
  const margin = 80;
  const newX = Math.random()*(560 - margin*2) + margin;
  const newY = Math.random()*(360 - margin*2) + margin;
  const dx = (state.pos?.x || newX) - newX;
  const dy = (state.pos?.y || newY) - newY;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const energyLoss = Math.max(1, Math.round(dist/60));
  state.pos.x = newX; state.pos.y = newY;
  state.energy = Math.max(0, state.energy - energyLoss);
  // apply transform for smoother animation
  gubbySprite.style.left = newX + 'px';
  gubbySprite.style.top = newY + 'px';
  broadcast({ t:'action', action:{ type:'move', x:newX, y:newY, energyLoss, by:myPeerId }, seq:++localSeq, from:myPeerId });
  syncLocalAndPeers();
}
setInterval(wander, 3000);

/* decay + auto clicks */
setInterval(()=>{
  if(!state.alive) return;
  state.hunger = Math.max(0, state.hunger - 1);
  state.thirst = Math.max(0, state.thirst - 1.2);
  const hour = (new Date()).getHours();
  if(hour>=22 || hour<7) state.energy = Math.min(100, state.energy + 2); else state.energy = Math.max(0, state.energy - 0.5);
  if(state.hunger === 0 || state.thirst ===0) state.energy = Math.max(0, state.energy - 2);
  if(state.upgrades.autoClicks > 0) {
    addClicks(state.upgrades.autoClicks);
    broadcast({ t:'action', action:{ type:'auto_click', value: state.upgrades.autoClicks, by:myPeerId }, seq:++localSeq, from:myPeerId });
  }
  if(state.energy <= 0 || state.hunger <= 0 || state.thirst <= 0){
    // Game Over triggered and broadcast
    state.alive = false;
    broadcast({ t:'gameover', seq:++localSeq, from:myPeerId });
    showGameOver();
  }
  syncLocalAndPeers();
}, 10000);

/* add clicks helper */
function addClicks(n){ state.clicks += n; state.totalClicks += n; saveState(); applyUI(); }

/* =========== Game Over modal (sync across peers) =========== */
function showGameOver(){
  const backdrop = el('gameOverBackdrop');
  const box = el('gameOverBox');
  backdrop.style.display = 'flex';
  setTimeout(()=> box.classList.add('show'), 10);
  // disable inputs by setting state.alive = false; already done upstream
}
function hideGameOver(){
  const backdrop = el('gameOverBackdrop');
  const box = el('gameOverBox');
  box.classList.remove('show');
  setTimeout(()=> backdrop.style.display = 'none', 200);
}
el('restartBtn').addEventListener('click', ()=> {
  // restart for all: reset state and broadcast authoritative reset
  state = JSON.parse(JSON.stringify(defaultState)); // reset
  broadcast({ t:'game_reset', state, seq:++localSeq, from:myPeerId });
  saveState(); applyUI(); hideGameOver();
});
el('closeGameOver').addEventListener('click', ()=> hideGameOver());

/* ============ P2P WebRTC Manual Signaling (secure-ish) ============ */
let pc = null, dc = null, isHost = false, lastOfferId = null;

function preparePeerConnection(){
  const config = { iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }] };
  pc = new RTCPeerConnection(config);
  pc.onicecandidate = ()=> {
    if(pc.iceGatheringState === 'complete'){
      const out = { type:'offer', sdp: pc.localDescription.sdp, id:lastOfferId, from:myPeerId, name: user?.displayName || user?.email || 'guest' };
      el('inviteOut').value = btoa(JSON.stringify(out));
    }
  };
  pc.ondatachannel = ev => { dc = ev.channel; setupDataChannel(dc); };
  pc.onconnectionstatechange = ()=> {
    if(pc.connectionState === 'connected') showStatus('Peer connected');
  };
}

function startHostInvite(){
  if(pc) return alert('Already connected; disconnect first.');
  isHost = true; lastOfferId = randomId();
  preparePeerConnection();
  dc = pc.createDataChannel('gubby');
  setupDataChannel(dc);
  pc.createOffer().then(o => pc.setLocalDescription(o)).then(()=>{
    const obj = { type:'offer', sdp: pc.localDescription.sdp, id:lastOfferId, from:myPeerId, name: user?.displayName || user?.email || 'guest' };
    el('inviteOut').value = btoa(JSON.stringify(obj));
    alert('Invite created. Copy inviteOut and send it to friend.');
  }).catch(e=>{ console.error(e); alert('Offer failed: '+e.message); });
}

function setupDataChannel(channel){
  channel.onopen = ()=> { showStatus('Data channel open'); /* send initial presence */ send({ t:'presence', id:myPeerId, seq:++localSeq, from:myPeerId, name:user?.displayName || user?.email || 'guest' }); };
  channel.onmessage = ev => { try{ const msg = JSON.parse(ev.data); handleMessage(msg); }catch(e){ console.warn('Bad message', e); } };
  channel.onclose = ()=> showStatus('Data channel closed');
}

function validateMsg(msg){
  if(!msg || typeof msg !== 'object') return false;
  if(!msg.t || !msg.from) return false;
  // seq monotonic check
  const seq = Number(msg.seq || 0);
  const prev = peerSeq[msg.from] || 0;
  if(seq <= prev) { console.warn('Dropping old/replayed msg', msg); return false; }
  peerSeq[msg.from] = seq;
  return true;
}

function handleMessage(msg){
  if(!validateMsg(msg)) return;
  if(msg.t === 'presence'){ showStatus('Peer: '+(msg.name||msg.from)); return; }
  if(msg.t === 'stateSync'){ if(msg.state) mergeRemoteState(msg.state); return; }
  if(msg.t === 'action'){ if(msg.action) applyRemoteAction(msg.action); return; }
  if(msg.t === 'gameover'){ state.alive = false; saveState(); applyUI(); showGameOver(); return; }
  if(msg.t === 'game_reset'){ state = msg.state || JSON.parse(JSON.stringify(defaultState)); saveState(); applyUI(); hideGameOver(); return; }
  // ignore unknown types for safety
  console.log('recv msg', msg);
}

function send(obj){
  if(!obj) return;
  obj.seq = ++localSeq;
  obj.from = myPeerId;
  if(dc && dc.readyState === 'open') dc.send(JSON.stringify(obj));
}

/* wrapper for broadcasting action/state */
function broadcast(obj){
  send(obj); // sends to connected peer
  // also apply locally if the action is something we want immediate (many callers already modify state)
}

/* host/guest invite processing */
async function processInviteString(b64){
  let obj=null;
  try{ obj = JSON.parse(atob(b64)); }catch(e){ return alert('Invalid invite format'); }
  if(obj.type === 'offer'){
    // act as answerer
    isHost = false; lastOfferId = obj.id;
    preparePeerConnection();
    await pc.setRemoteDescription({ type:'offer', sdp: obj.sdp });
    const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);
    const answerObj = { type:'answer', sdp: pc.localDescription.sdp, id: obj.id, from: myPeerId };
    el('inviteOut').value = btoa(JSON.stringify(answerObj));
    alert('Created answer — send inviteOut back to host.');
  } else if(obj.type === 'answer'){
    if(!pc) return alert('No offer present — host must create invite first.');
    await pc.setRemoteDescription({ type:'answer', sdp: obj.sdp });
    alert('Answer processed — trying to connect.');
  } else alert('Unknown invite type: '+obj.type);
}

/* wiring invite UI */
el('createInviteShort').addEventListener('click', ()=> startHostInvite());
el('copyInviteBtn').addEventListener('click', ()=> {
  const val = el('inviteOut').value;
  if(!val) return alert('No invite to copy'); navigator.clipboard?.writeText(val).then(()=>alert('Copied'), ()=>alert('Copy failed'));
});
el('processInvite').addEventListener('click', ()=> {
  const txt = el('inviteIn').value.trim(); if(!txt) return alert('Paste invite first'); processInviteString(txt);
});
el('processAnswer').addEventListener('click', ()=> {
  const val = el('inviteOut').value.trim(); if(!val) return alert('No answer created'); prompt('Send this answer to host (copy):', val);
});
el('disconnectBtn').addEventListener('click', ()=> disconnectPeer());

function disconnectPeer(){ try{ if(dc) dc.close(); }catch(e){} try{ if(pc) pc.close(); }catch(e){} dc=null; pc=null; isHost=false; lastOfferId=null; el('inviteOut').value=''; el('inviteIn').value=''; showStatus('Disconnected'); }

/* =========== Remote actions handling =========== */
function mergeRemoteState(remote){
  if(!remote) return;
  // prefer highest totalClicks
  if(remote.totalClicks > state.totalClicks){
    state.totalClicks = remote.totalClicks;
    state.upgrades = remote.upgrades || state.upgrades;
    state.variant = remote.variant || state.variant;
  }
  // backpack: take max (simple merge strategy)
  state.backpack.food = Math.max(state.backpack.food, remote.backpack?.food || 0);
  state.backpack.water = Math.max(state.backpack.water, remote.backpack?.water || 0);
  state.backpack.cola = Math.max(state.backpack.cola, remote.backpack?.cola || 0);
  // average bars
  state.hunger = Math.round((state.hunger + (remote.hunger||state.hunger))/2);
  state.thirst = Math.round((state.thirst + (remote.thirst||state.thirst))/2);
  state.energy = Math.round((state.energy + (remote.energy||state.energy))/2);
  saveState(); applyUI();
}

function applyRemoteAction(action){
  if(!action || !action.type) return;
  if(action.type === 'click'){ addClicks(action.value || 1); playMerp(); }
  if(action.type === 'move'){ state.pos.x = action.x; state.pos.y = action.y; state.energy = Math.max(0, state.energy - (action.energyLoss||1)); gubbySprite.style.left = state.pos.x + 'px'; gubbySprite.style.top = state.pos.y + 'px'; }
  if(action.type === 'use_item'){ if(action.item && state.backpack[action.item] !== undefined){ if(typeof action.count === 'number') state.backpack[action.item] = action.count; else state.backpack[action.item] = Math.max(0, (state.backpack[action.item]||0) -1); } }
  if(action.type === 'purchase'){ /* optionally reflect purchase - we rely on state.totalClicks merging and shop logic */ }
  if(action.type === 'auto_click'){ addClicks(action.value || 1); }
  if(action.type === 'play'){ state.energy = Math.min(100, state.energy + 8); }
  saveState(); applyUI();
  // if action indicates gameover trigger
  if(!state.alive && (state.hunger <=0 || state.thirst<=0 || state.energy<=0)) showGameOver();
}

/* =========== Firebase admin (optional, lazy init) =========== */
function initFirebase(){
  if(window.firebase && !auth){
    firebase.initializeApp(firebaseConfig);
    auth = firebase.auth();
    db = firebase.firestore();
    auth.onAuthStateChanged(async u=>{
      if(u){ user = u; try{ const userRef = db.collection('users').doc(u.uid); const doc = await userRef.get(); if(!doc.exists) await userRef.set({ displayName:u.displayName||u.email.split('@')[0], email:u.email, privileges:'normal', createdAt:Date.now() }); const profile = (await userRef.get()).data(); if(profile.privileges==='admin') el('adminPanel').style.display='block'; else el('adminPanel').style.display='none'; }catch(e){ console.warn(e); } }
      else { user = null; el('adminPanel').style.display='none'; }
      applyUI();
    });
    db.collection('variants').onSnapshot(snap => renderVariantsFromFirestore(snap.docs.map(d=>({id:d.id,...d.data()}))));
    db.collection('shop').onSnapshot(snap => {/* optional */});
  }
}
el('googleSignIn').addEventListener('click', ()=> { if(!auth) initFirebase(); if(!auth) return alert('Firebase init failed'); const provider = new firebase.auth.GoogleAuthProvider(); auth.signInWithPopup(provider).catch(e=>alert('Sign in failed: '+e.message)); });

/* admin create variant */
el('createVariantBtn')?.addEventListener('click', async ()=>{
  if(!db || !auth || !auth.currentUser) return alert('Sign-in required');
  const id = el('variantId').value.trim(), file = el('variantFile').value.trim(); const price = Number(el('variantPrice').value)||0;
  let attrs={}; try{ attrs = JSON.parse(el('variantAttrs').value || '{}'); }catch(e){ return alert('Invalid JSON'); }
  if(!id || !file) return alert('Provide id & file');
  try{
    const res = await fetch(SPRITE_BASE_PATH + file, {method:'HEAD'});
    if(!res.ok && !confirm('Sprite missing — create anyway?')) return;
  }catch(e){ if(!confirm('Cannot verify sprite — continue?')) return; }
  try{ await db.collection('variants').add({ id, fileName:file, price, attributes:attrs, createdBy:auth.currentUser.uid, createdAt:Date.now() }); await db.collection('shop').add({ type:'variant', variantFile:file, variantId:id, price, attributes:attrs }); alert('Created'); }catch(e){ alert('Error: '+e.message); }
});

/* render firestore variants */
function renderVariantsFromFirestore(items){
  const wrap = el('variantsList'); wrap.innerHTML = '';
  items.forEach(v=>{ const d = document.createElement('div'); d.className='variant-item'; d.textContent = `${v.fileName}${v.price? ' — '+v.price:''}`; d.addEventListener('click', ()=>{ state.variant = v.fileName; syncLocalAndPeers(); }); wrap.appendChild(d); });
}

/* =========== Sync & save =========== */
function syncLocalAndPeers(){ saveState(); applyUI(); if(dc && dc.readyState==='open') send({ t:'stateSync', state, seq:++localSeq, from:myPeerId }); }

/* expose debug */
window.GubbyClicker = { state, saveState, loadState, openShop, startHostInvite: startHostInvite, processInviteString: processInviteString, disconnectPeer };

/* finalize UI */
applyUI();

</script>
</body>
</html>
